
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>PayPal题库 &#8212; blog  文档</title>
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="MathWorks题库" href="../mathworks-interview/index.html" />
    <link rel="prev" title="前缀和太好用了" href="../prefix-sum/index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../mathworks-interview/index.html" title="MathWorks题库"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../prefix-sum/index.html" title="前缀和太好用了"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">blog  文档</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="paypal">
<h1>PayPal题库</h1>
<p>收到了PayPal的面试呀，来刷一遍PayPal的题目吧。</p>
<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#paypal" id="id30">PayPal题库</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id31">机器人出不出圈</a></p></li>
<li><p><a class="reference internal" href="#zigzag" id="id32">按ZigZag顺序格式化字符串</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id33">两个元素下标的最小距离</a></p></li>
<li><p><a class="reference internal" href="#two-sum" id="id34">Two sum</a></p></li>
<li><p><a class="reference internal" href="#lru" id="id35">实现LRU缓存</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id36">螺旋遍历矩阵</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id37">两个词是否是颠倒字母顺序形成的</a></p></li>
<li><p><a class="reference internal" href="#k" id="id38">数列里有多少对差的绝对值正好是 <span class="math notranslate nohighlight">\(k\)</span> 的数对</a></p></li>
<li><p><a class="reference internal" href="#peek" id="id39">实现支持 <code class="docutils literal notranslate"><span class="pre">peek()</span></code> 的迭代器</a></p></li>
<li><p><a class="reference internal" href="#subsequence-sum" id="id40">Subsequence sum</a></p></li>
<li><p><a class="reference internal" href="#array0" id="id41">把array里所有的0都移动到最后</a></p></li>
<li><p><a class="reference internal" href="#k-k" id="id42"><span class="math notranslate nohighlight">\(k\)</span> 个 <span class="math notranslate nohighlight">\(k\)</span> 个颠倒链表</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id43">颠倒链表</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id44">从链表里删除节点</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id45">二叉树的右视图</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id46">二叉树按层遍历</a></p></li>
<li><p><a class="reference internal" href="#substring" id="id47">累加和最大的substring</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id48">二叉树中两个节点的最近公共祖先</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id49">判断某个值是否在排好序的矩阵里</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id50">验证括号嵌套</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id51">给颜色排序</a></p></li>
<li><p><a class="reference internal" href="#id19" id="id52">遇到 <code class="docutils literal notranslate"><span class="pre">0</span></code> 就把这行这列全设成 <code class="docutils literal notranslate"><span class="pre">0</span></code></a></p></li>
<li><p><a class="reference internal" href="#id20" id="id53">列出所有组合</a></p></li>
<li><p><a class="reference internal" href="#array" id="id54">整个array除了自己的以外的积</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id55">合并几个排好序的链表</a></p></li>
<li><p><a class="reference internal" href="#sum" id="id56">3 sum</a></p></li>
<li><p><a class="reference internal" href="#id23" id="id57">面试体验</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2>机器人出不出圈</h2>
<p><a class="reference external" href="https://leetcode.com/problems/robot-bounded-in-circle/">Leetcode 1041</a></p>
<blockquote>
<div><p>给一组指令， <code class="docutils literal notranslate"><span class="pre">G</span></code> 表示往前走一格、 <code class="docutils literal notranslate"><span class="pre">L</span></code> 表示左转、 <code class="docutils literal notranslate"><span class="pre">R</span></code> 表示右转。机器人一开始头朝前。机器人循环执行这一组指令，机器人的轨迹是有界的吗？</p>
</div></blockquote>
<p>只要执行一次整组指令，然后看机器人</p>
<ul class="simple">
<li><p>位置是否不在原点</p></li>
<li><p>并且头是不是朝着前</p></li>
</ul>
<p>如果这两个条件都满足，机器人的轨迹一定是无界的。</p>
<p>翻遍了评论区也没有找到严格证明。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isRobotBounded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instructions</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;up&quot;</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span>
                    <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span>
                    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;down&quot;</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;up&quot;</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span>
                    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;up&quot;</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;down&quot;</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span>
                    <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>

        <span class="k">if</span> <span class="n">position</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
</div>
<div class="section" id="zigzag">
<h2>按ZigZag顺序格式化字符串</h2>
<p><a class="reference external" href="https://leetcode.com/problems/zigzag-conversion/">Leetcode 6</a></p>
<p>非常无聊的一道题……而且我怀疑是PayPal出的题。</p>
<blockquote>
<div><p>给一个字符串、行数，把字符串按往下、右斜上方、再往下这样循环输出。</p>
</div></blockquote>
<p>比如给</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PAYPALISHIRING</span><span class="p">,</span> <span class="mi">3</span>
</pre></div>
</div>
<p>变成</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="n">A</span> <span class="n">H</span> <span class="n">N</span>
<span class="n">APLSIIG</span>
<span class="n">Y</span> <span class="n">I</span> <span class="n">R</span>
</pre></div>
</div>
<p>然后再按从左到右、从上到下顺序输出，变成</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PAHNAPLSIIGYIR</span>
</pre></div>
</div>
<p>真的是非常无聊。</p>
<p>观察一下字符的排列方式</p>
<ul class="simple">
<li><p>0到 <span class="math notranslate nohighlight">\(n - 1\)</span> 是从上到下排</p></li>
<li><p><span class="math notranslate nohighlight">\(n - 1\)</span> 到 <span class="math notranslate nohighlight">\(2n - 1\)</span> 是从下往上排</p></li>
<li><p><span class="math notranslate nohighlight">\(2(n - 1)\)</span> 到 <span class="math notranslate nohighlight">\(3(n - 1)\)</span> 又是从上往下</p></li>
</ul>
<p>不如从格式化之后的行数来看，我们往每一行追加字符的顺序是</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(0, 1, ..., n - 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(n, n - 1, ..., 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(0, 1, ..., n - 1\)</span></p></li>
</ul>
<p>可以看出就是</p>
<div class="math notranslate nohighlight">
\[0, 1, 2, ..., n - 1, n, n - 1, n - 2, ..., 1\]</div>
<p>不停循环</p>
<p>在Python里这个迭代器可以这么写</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</div>
<p>括号好多……Rust就好看许多</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">0</span><span class="p">..</span><span class="n">n</span><span class="p">).</span><span class="n">chain</span><span class="p">((</span><span class="mi">1</span><span class="p">..</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">rev</span><span class="p">())</span><span class="w"></span>
</pre></div>
</div>
<p>注意Rust里 <code class="docutils literal notranslate"><span class="pre">(0..10)</span></code> 这种 <code class="docutils literal notranslate"><span class="pre">Range</span></code> 本身就已经是一个 <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> 了， <code class="docutils literal notranslate"><span class="pre">(0..10).iter()</span></code> 是错的。</p>
<p>所以给每一横排建一个列表，然后按顺序生成行数，遍历字符串，追加到对应的那一行就好了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">itertools</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">numRows</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRows</span><span class="p">)]</span>
        <span class="n">rowIndexIterator</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">numRows</span><span class="p">),</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numRows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rowIndexIterator</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
            <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="p">[]))</span>
</pre></div>
</div>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Solution</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">convert</span><span class="p">(</span><span class="n">s</span>: <span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">num_rows</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">chars</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rows</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">vec</span><span class="o">!</span><span class="p">[];</span><span class="w"> </span><span class="n">num_rows</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">..</span><span class="n">num_rows</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">chain</span><span class="p">((</span><span class="mi">1</span><span class="p">..</span><span class="n">num_rows</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">rev</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">cycle</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rows</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Solution</span>::<span class="n">convert</span><span class="p">(</span><span class="s">&quot;PAYPALISHIREING&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>两个元素下标的最小距离</h2>
<p><a class="reference external" href="https://leetcode.com/problems/shortest-word-distance/">Leetcode 243</a></p>
<blockquote>
<div><p>给一个array，里面有好多元素，有重复元素。再给你两个元素 <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span></code> ，所有 <code class="docutils literal notranslate"><span class="pre">a</span></code> 出现的下标、和所有 <code class="docutils literal notranslate"><span class="pre">b</span></code> 出现的下标的差的绝对值的最小值是多少。</p>
</div></blockquote>
<p>就是求</p>
<div class="math notranslate nohighlight">
\[\min\left\{|i - j| \middle| a = a_i, b = a_j \right\}\]</div>
<p>很简单啦，先把 <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span></code> 出现的下标全部找出来，再一个一个对比就好了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">shortestDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">word1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">word2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">indices1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indices2</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">word1</span><span class="p">:</span>
                <span class="n">indices1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="n">word2</span><span class="p">:</span>
                <span class="n">indices2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="two-sum">
<h2>Two sum</h2>
<p><a class="reference external" href="https://leetcode.com/problems/two-sum/">Leetcode 1</a></p>
<blockquote>
<div><p>给一个array，array里是否存在两个数字加起来正好是 <span class="math notranslate nohighlight">\(t\)</span> ？它们的坐标是什么？</p>
</div></blockquote>
<p>用hash map存目前为止见过的所有的数（作为key）和数字的出现的位置（作为value），遍历array，对于每个元素 <span class="math notranslate nohighlight">\(b\)</span> ，都去hash map里找是否存在 <span class="math notranslate nohighlight">\(t - b\)</span> 这个数字。因为 <span class="math notranslate nohighlight">\(b + t - b = t\)</span> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">-</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">seen</span><span class="p">[</span><span class="n">target</span> <span class="o">-</span> <span class="n">v</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="lru">
<h2>实现LRU缓存</h2>
<p><a class="reference external" href="https://leetcode.com/problems/lru-cache/">Leetcode 146</a></p>
<blockquote>
<div><p>实现least recently used缓存。</p>
</div></blockquote>
<p>所谓least recently used就是上一次使用时间最远。当缓存容量满的时候，寻找上一次时间最远的那个元素，从缓存里删掉，给新元素腾出空间。</p>
<p>这道题刚做不久，但是已经忘光了，看来人脑也是个LRU缓存……那再来分析一下。</p>
<p>单独用一个hash map肯定是不够的，因为hash map虽然能在 <span class="math notranslate nohighlight">\(O(1)\)</span> 判断元素是否存在，但是没法做到保存元素的顺序。单独用一个array肯定也是不够的，因为array虽然能做到保存元素顺序，但是做不到 <span class="math notranslate nohighlight">\(O(1)\)</span> 判断某个元素是否在array里。</p>
<p>所以基本确定这道题是用一个hash map和一个array做。问题是hash map的key、value和array的value分别存什么呢？</p>
<p>首先能确定，hash map的key肯定只能存cache的内容，因为需要 <span class="math notranslate nohighlight">\(O(1)\)</span> 判断内容是否在cache里，这个没得商量。</p>
<p>需要腾出位置的时候，要读array最后一个格子的内容，快速确定是哪个内容要从cache里删掉，所以array里必须也存cache的内容，也就是和hash map的key保持一致。</p>
<p>到这里都没有问题，我们继续研究hash map的value应该存什么。读出内容之后，还要把这个内容的最近访问时间提到最前面，这件事情，array是做不到的……想想如果用hash map的value存的是下标，某个中间的内容最近被访问了，中间的格子要出来、放到最前面，这样的话前面这么多个格子的下标全部都会变。</p>
<div class="figure align-default" id="id28">
<img alt="../../_images/lru-cache.svg" src="../../_images/lru-cache.svg" /><p class="caption"><span class="caption-number">图 2 </span><span class="caption-text">没空间可用的时候，要删掉 <code class="docutils literal notranslate"><span class="pre">w</span></code> 给 <code class="docutils literal notranslate"><span class="pre">k</span></code> 腾出空间，但是这样一来， <code class="docutils literal notranslate"><span class="pre">k</span></code> 的访问时间变成最近了， <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></code> 都要往后移动。</span></p>
</div>
<p>我记得amazon的文章里我好像做过这个图了……</p>
<p>所以只能用linked list了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">LinkedListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">previous</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">next</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">previous</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">next</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="nb">next</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">previous</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">next</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">previous</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">next</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="n">next</span>
            <span class="n">previous</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span><span class="o">.</span><span class="n">previous</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">insertAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">LinkedListNode</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">previous</span> <span class="o">=</span> <span class="n">node</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="n">next</span>

        <span class="n">previou</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span>
        <span class="k">if</span> <span class="nb">next</span><span class="p">:</span>
            <span class="nb">next</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">LinkedListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">LinkedListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">insertAfter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">insertAfter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">)</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">:</span>
            <span class="n">lastNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">previous</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">lastNode</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">lastNode</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

            <span class="n">node</span> <span class="o">=</span> <span class="n">LinkedListNode</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="c1"># Your LRUCache object will be instantiated and called as such:</span>
<span class="c1"># obj = LRUCache(capacity)</span>
<span class="c1"># param_1 = obj.get(key)</span>
<span class="c1"># obj.put(key,value)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>螺旋遍历矩阵</h2>
<p><a class="reference external" href="https://leetcode.com/problems/spiral-matrix/">Leetcode 54</a></p>
<blockquote>
<div><p>给一个矩阵，按左上角到右上角、右上角到右下角、右下角到左下角、左下角到左上角、再到内层的顺序遍历。</p>
</div></blockquote>
<p>比如给</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left(\begin{matrix}
    1 &amp; 2 &amp; 3 &amp; 4 \\
    5 &amp; 6 &amp; 7 &amp; 8 \\
    9 &amp; 10 &amp; 11 &amp; 12 \\
\end{matrix}\right)\end{split}\]</div>
<p>输出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span>
</pre></div>
</div>
<p>很简单，用递归就好了，像剥洋葱一样一层一层剥开来就好了。</p>
<p>假设矩阵是 <span class="math notranslate nohighlight">\(n \times m\)</span> 的，那么最外层怎么剥呢？最外层的下标是</p>
<div class="math notranslate nohighlight">
\[\overbrace{(0, 0)}^\text{左上角}, (0, 1), ..., \overbrace{(0, m - 1)}^\text{右上角}, (1, m - 1), (2, m - 1), ..., \underbrace{(n - 1, m - 1)}_\text{右下角}, (n - 1, m - 2), (n - 1, m - 3), ..., (n - 1, 1), \underbrace{(n - 1, 0)}_\text{左下角}, (n - 2, 0), ..., (1, 0)\]</div>
<p>分成四段</p>
<ul class="simple">
<li><p>左上角到右上角前 <span class="math notranslate nohighlight">\((0, 0), (0, 1), ..., (0, m - 2)\)</span></p></li>
<li><p>右上角到右下角前 <span class="math notranslate nohighlight">\((0, m - 1), (2, m - 1), ..., (n - 2, m - 1)\)</span></p></li>
<li><p>右下角到左下角前 <span class="math notranslate nohighlight">\((n - 1, m - 1), (n - 1, m - 2), ..., (n - 1, 1)\)</span></p></li>
<li><p>左下角到左上角前 <span class="math notranslate nohighlight">\((n - 1, 0), (n - 2, 0), ..., (1, 0)\)</span></p></li>
</ul>
<p>分别对应四个迭代器</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">i)</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(m</span> <span class="pre">-</span> <span class="pre">1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(n</span> <span class="pre">-</span> <span class="pre">1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">i)</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">reversed(range(1,</span> <span class="pre">m))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">0)</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">reversed(range(1,</span> <span class="pre">n))</span></code></p></li>
</ul>
<p>Python里就用 <code class="docutils literal notranslate"><span class="pre">itertools.chain()</span></code> 把四个迭代器串起来就好了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spiralOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">rowCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">columnCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">columnCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 可能会是 [[], [], []]</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">rowCount</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">columnCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 1x1的特殊处理</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">rowCount</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">columnCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 1xn的特殊处理</span>
            <span class="k">return</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">rowCount</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">columnCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># nx1的特殊处理</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># rowCount &gt; 1 and columnCount &gt; 1</span>
            <span class="n">indiceIterator</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columnCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">columnCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="p">[(</span><span class="n">rowCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">columnCount</span><span class="p">))]</span>
                <span class="o">+</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rowCount</span><span class="p">))]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indiceIterator</span><span class="p">:</span> <span class="c1"># 剥开洋葱的最外层</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

            <span class="c1"># 然后要删掉我们刚才已经剥掉的部分</span>

            <span class="n">matrix</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 删掉第一行</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 删掉最后一行</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">:</span> <span class="c1"># 删掉每一行的第一个元素和最后一个元素</span>
                <span class="n">v</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">v</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spiralOrder</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span> <span class="c1"># 剥开内层</span>
            <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>两个词是否是颠倒字母顺序形成的</h2>
<p><a class="reference external" href="https://leetcode.com/problems/valid-anagram/">Leetcode 242</a></p>
<blockquote>
<div><p>给两个字符串 <code class="docutils literal notranslate"><span class="pre">s,</span> <span class="pre">t</span></code> ，问 <code class="docutils literal notranslate"><span class="pre">s,</span> <span class="pre">t</span></code> 是否含有相同种类的字母、并且每种字母在各自字符串里出现的参数相同。</p>
</div></blockquote>
<p>比如给</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;anagram&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">&quot;nagaram&quot;</span></code></p></li>
</ul>
<p>发现 <code class="docutils literal notranslate"><span class="pre">s,</span> <span class="pre">t</span></code> 都含有</p>
<ul class="simple">
<li><p>3个 <code class="docutils literal notranslate"><span class="pre">a</span></code></p></li>
<li><p>1个 <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p>1个 <code class="docutils literal notranslate"><span class="pre">m</span></code></p></li>
<li><p>1个 <code class="docutils literal notranslate"><span class="pre">g</span></code></p></li>
</ul>
<p>最容易想到的就是用hash map，统计每个词里每个字母出现的次数，然后比较这两个hash map是否完全相等。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">counter1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">counter1</span><span class="p">:</span>
                <span class="n">counter1</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">counter1</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">counter2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">counter2</span><span class="p">:</span>
                <span class="n">counter2</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">counter2</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">counter1</span> <span class="o">==</span> <span class="n">counter2</span>
</pre></div>
</div>
<p>用 <code class="docutils literal notranslate"><span class="pre">collections.Counter</span></code> 只要一行</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="k">
<h2>数列里有多少对差的绝对值正好是 <span class="math notranslate nohighlight">\(k\)</span> 的数对</h2>
<p><a class="reference external" href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">Leetcode 532</a></p>
<blockquote>
<div><p>给一个数列，其中有多少对数 <span class="math notranslate nohighlight">\((v, w), v \leq w\)</span> 满足 <span class="math notranslate nohighlight">\(|v - w| = k\)</span> ？</p>
</div></blockquote>
<p>比如给 <span class="math notranslate nohighlight">\(k = 2\)</span> 和</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>
</div>
<p>就有</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">3)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">5)</span></code></p></li>
</ul>
<p>满足条件。虽然里面有两个1，但是只算一对。</p>
<p>要注意比较坑的test case，比如 <span class="math notranslate nohighlight">\(k &lt; 0\)</span> 的情况……绝对值怎么可能小于零呢？所以这时候就直接返回0。</p>
<p>还有是 <span class="math notranslate nohighlight">\(k = 0\)</span> 的情况，要特殊处理。比如给 <span class="math notranslate nohighlight">\(k = 0\)</span> 和</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>
</div>
<p>的时候，答案是1，因为只有一对 <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">1)</span></code> 满足条件。但是如果给 <span class="math notranslate nohighlight">\(k = 0\)</span> 和</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>
</pre></div>
</div>
<p>那么答案又变成0了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 绝对值不可能小于0</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 等于0的时候特殊处理</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">counter</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># 数一下有多少个数出现的次数大于等于2的</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># k &gt; 0</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seen</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">+</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="c1"># 永远往大的方向看，这样就不会重复计数了</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
<p>能理解这题为什么得分这么低了……</p>
</div>
<div class="section" id="peek">
<h2>实现支持 <code class="docutils literal notranslate"><span class="pre">peek()</span></code> 的迭代器</h2>
<p><a class="reference external" href="https://leetcode.com/problems/peeking-iterator/">Leetcode 284</a></p>
<blockquote>
<div><p>众所周知，迭代器的 <code class="docutils literal notranslate"><span class="pre">next()</span></code> 是 <strong>取出</strong> 下一个元素，但是如果我不想取出呢？我只想看看，不想拿出来的。实现一个和stack一样的 <code class="docutils literal notranslate"><span class="pre">peek()</span></code> 方法。</p>
</div></blockquote>
<p>很简单，内部搞一个cache，暂存一下内部那个迭代器的第一个元素。每次 <code class="docutils literal notranslate"><span class="pre">peek()</span></code> 就返回这个cache。每次 <code class="docutils literal notranslate"><span class="pre">next()</span></code> 就返回这个cache，再取出内部迭代器的下一个元素，放到cache里。</p>
<p>如果cache是空的，就说明取完了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Below is the interface for Iterator, which is already defined for you.</span>
<span class="c1">#</span>
<span class="c1"># class Iterator:</span>
<span class="c1">#     def __init__(self, nums):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Initializes an iterator object to the beginning of a list.</span>
<span class="c1">#         :type nums: List[int]</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     def hasNext(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Returns true if the iteration has more elements.</span>
<span class="c1">#         :rtype: bool</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     def next(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Returns the next element in the iteration.</span>
<span class="c1">#         :rtype: int</span>
<span class="c1">#         &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">PeekingIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize your data structure here.</span>
<span class="sd">        :type iterator: Iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="n">iterator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">hasNext</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="c1"># 先把内部迭代器的第一个元素取出来放到cache里</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next element in the iteration without advancing the iterator.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="c1"># peek的时候返回cache就好了</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="c1"># 返回cache</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">hasNext</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="c1"># 并且把cache设置为内部迭代器的下一个元素</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span> <span class="c1"># cache不为空，就可以取</span>

<span class="c1"># Your PeekingIterator object will be instantiated and called as such:</span>
<span class="c1"># iter = PeekingIterator(Iterator(nums))</span>
<span class="c1"># while iter.hasNext():</span>
<span class="c1">#     val = iter.peek()   # Get the next element but not advance the iterator.</span>
<span class="c1">#     iter.next()         # Should return the same value as [val].</span>
</pre></div>
</div>
</div>
<div class="section" id="subsequence-sum">
<h2>Subsequence sum</h2>
<p>虽然题号里有subset sum，但是并不是严格的集合，因为允许重复元素。所以这里标题改成了subsequence sum。</p>
<p><a class="reference external" href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode 416</a></p>
<blockquote>
<div><p>给一个全是整数的array，这个array存不存在一个subsequence（可以不连续），它的累加和正好是整个array的累加和的一半？</p>
</div></blockquote>
<p>这个一半没什么特别的，并不能让问题变简单，换成任意的 <span class="math notranslate nohighlight">\(t\)</span> 也是一样的，所以问题等价于</p>
<blockquote>
<div><p>给一个全是整数的array，这个array存不存在一个subsequence（可以不连续），它的累加和正好 <span class="math notranslate nohighlight">\(t\)</span> ？</p>
</div></blockquote>
<p>看到题目惊了，subset sum不是NP hard吗，怎么这种题目都搬出来了。一想哦原来是整数subset sum，那么伪多项式阶用动态规划 <a class="footnote-reference brackets" href="#pseudo-polynomial" id="id6">1</a> 还是能解的。</p>
<p>设 <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> 是array的前 <span class="math notranslate nohighlight">\(i\)</span> 个数字各种组合、能凑成的所有可能的和。那么 <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> 和前面的项有什么关系呢？假设第 <span class="math notranslate nohighlight">\(i\)</span> 个数字是 <span class="math notranslate nohighlight">\(a_i\)</span> ，那么</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(a_i\)</span> 单独可能成一个累加和</p></li>
<li><p><span class="math notranslate nohighlight">\(a_i\)</span> 可以和前面的所有累加和加起来，形成新的和</p></li>
</ul>
<p>所以递推式很容易写</p>
<div class="math notranslate nohighlight">
\[\text{OPT}(i) = \text{OPT}(i - 1) \cup \{a_i\} \cup \{a_i + v | v \in \text{OPT}(i - 1)\}\]</div>
<p>如果这样做其实复杂度和暴力一样……但是有个优化可以用一下。</p>
<p>有没有发现array里面每个数字都是正整数？那么如果 <code class="docutils literal notranslate"><span class="pre">dp[i</span> <span class="pre">-</span> <span class="pre">1]</span></code> 里面的某个和 <span class="math notranslate nohighlight">\(v\)</span> 已经大于 <span class="math notranslate nohighlight">\(t\)</span> 了，这个数字还需要保留到 <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> 里面吗？显然不用保留了，因为再继续保留下去，和 <span class="math notranslate nohighlight">\(a_i\)</span> 加一下只会变得更大、离 <span class="math notranslate nohighlight">\(t\)</span> 更远。</p>
<p>所以加一个条件判断，所有大于 <span class="math notranslate nohighlight">\(t\)</span> 的数字都没有必要保留</p>
<div class="math notranslate nohighlight">
\[\text{OPT}(i) = \text{OPT}(i - 1) \cup \{a_i\} \cup \{a_i + v | v \in \text{OPT}(i - 1), a_i + v \leq t\}\]</div>
<p>这样，任意一个 <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> 的大小都不会超过 <span class="math notranslate nohighlight">\(t + 1\)</span> ，所以算法的复杂度和转化成01背包问题一样，都是伪多项式阶 <span class="math notranslate nohighlight">\(O(n t)\)</span> 。</p>
<p>还可以优化空间复杂度。观察递推式， <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> 只和 <code class="docutils literal notranslate"><span class="pre">dp[i</span> <span class="pre">-</span> <span class="pre">1]</span></code> 有关，和 <code class="docutils literal notranslate"><span class="pre">dp[i</span> <span class="pre">-</span> <span class="pre">2],</span> <span class="pre">dp[i</span> <span class="pre">-</span> <span class="pre">3]</span></code> 都没有关系，所以每次只要保存上一轮的结果就可以了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canPartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">summation</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">summation</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">summation</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">summations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># dp[i - 1]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">newSummations</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">}</span> <span class="c1"># 没有办法一边遍历、一边插入，所以只能先建临时的</span>

            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">summations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">:</span> <span class="c1"># 大于t的没必要放进去</span>
                    <span class="n">newSummations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>

            <span class="n">summations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newSummations</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">summations</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="pseudo-polynomial"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p>关于NP hard和伪多项式阶可以看我的 <a class="reference internal" href="../reduction-np.html"><span class="doc">这篇文章</span></a> 呀。</p>
</dd>
</dl>
</div>
<div class="section" id="array0">
<h2>把array里所有的0都移动到最后</h2>
<p><a class="reference external" href="https://leetcode.com/problems/move-zeroes/">Leetcode 283</a></p>
<blockquote>
<div><p>给一个array，用尽可能少的操作，把里面所有0都移到array的最后面，保持其他非0元素的相对位置。</p>
</div></blockquote>
<p>比如给</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span>
</pre></div>
</div>
<p>要尽可能用最少的操作做到</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>
</div>
<p>如果要暴力做是很简单的，遇到一个0，就把它从array里面拿出来，然后放到最后。问题是，假设第一个元素就是0，把它拿出来之后，后面的 <span class="math notranslate nohighlight">\(n - 1\)</span> 个元素要依次顺位往前，这个开销就很大了。</p>
<p>那能不能用小水滴聚成大水滴、大水滴往后移动的方法？用两个指针表示大水滴的范围，范围内的数字全是 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，然后水滴不断往右移动，遇到 <code class="docutils literal notranslate"><span class="pre">0</span></code> 就吸收、遇到不是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的就让这个数和水滴最前面的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 交换位置。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span>
<span class="o">^</span>
<span class="o">^</span>
</pre></div>
</div>
<p>发现右边是 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，所以调换 <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span>
   <span class="o">^</span>
   <span class="o">^</span>
</pre></div>
</div>
<p>发现右边是 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，把水滴范围扩大</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span>
   <span class="o">^</span>  <span class="o">^</span>
</pre></div>
</div>
<p>右边遇到了 <code class="docutils literal notranslate"><span class="pre">3</span></code> ，怎么办？让 <code class="docutils literal notranslate"><span class="pre">3</span></code> 和水滴最前面的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 调换位置</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span>
      <span class="o">^</span>  <span class="o">^</span>
</pre></div>
</div>
<p>右边遇到了 <code class="docutils literal notranslate"><span class="pre">12</span></code> ，还是让 <code class="docutils literal notranslate"><span class="pre">12</span></code> 和水滴最前面的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 调换位置</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
          <span class="o">^</span>  <span class="o">^</span>
</pre></div>
</div>
<p>水滴已经移动到最右边了，结束。</p>
<p>这样算下来总共交换了3次，如果把写入array作为基本操作，那么做了6次操作。如果用暴力的做法</p>
<ul class="simple">
<li><p>第一次把最前面的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 拿出来放到最后需要5次操作</p></li>
<li><p>第二次把中间的  <code class="docutils literal notranslate"><span class="pre">0</span></code> 拿出来放到最后需要4次操作</p></li>
</ul>
<p>总共9次操作。</p>
<p>最极端的test case应该是这种</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>
</div>
<p>如果暴力，需要 <span class="math notranslate nohighlight">\(O(n^2)\)</span> 次操作。用这种水滴的方法就只要1次操作。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify nums in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 左闭</span>
            <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 右开</span>

            <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 遇到0</span>
                    <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 吸收</span>
                <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 遇到非0</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="c1"># 把右边的非0数和水滴的第一个数字交换位置</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
</pre></div>
</div>
<p>我也不知道我是怎么想到这个方法的，可能这就是灵感？</p>
</div>
<div class="section" id="k-k">
<h2><span class="math notranslate nohighlight">\(k\)</span> 个 <span class="math notranslate nohighlight">\(k\)</span> 个颠倒链表</h2>
<p><a class="reference external" href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode 25</a></p>
<blockquote>
<div><p>给一个链表，把元素分成 <span class="math notranslate nohighlight">\(k\)</span> 个一组，分组颠倒。最后一组如果不满 <span class="math notranslate nohighlight">\(k\)</span> 个就不要颠倒。</p>
</div></blockquote>
<p>大概就是给 <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5</span></code> 分2组颠倒的话得到</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>
</div>
<p>分3组颠倒的话就是</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>
</div>
<p>记得好像最近做过这题了……但是我又忘了，再做一遍吧。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseKGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="n">segmentCount</span> <span class="o">=</span> <span class="n">length</span> <span class="o">//</span> <span class="n">k</span>

        <span class="n">lastSegmentLastNode</span> <span class="o">=</span> <span class="n">sentinel</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segmentCount</span><span class="p">):</span>
            <span class="n">thisSegmentSentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">thisSegmentLastNode</span> <span class="o">=</span> <span class="n">head</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">thisSegmentSentinel</span><span class="o">.</span><span class="n">next</span>
                <span class="n">thisSegmentSentinel</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">newHead</span>

            <span class="n">lastSegmentLastNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">thisSegmentSentinel</span><span class="o">.</span><span class="n">next</span>
            <span class="n">lastSegmentLastNode</span> <span class="o">=</span> <span class="n">thisSegmentLastNode</span>

        <span class="n">lastSegmentLastNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

        <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>颠倒链表</h2>
<p><a class="reference external" href="https://leetcode.com/problems/reverse-linked-list/">Leetcode 206</a></p>
<p>这个就更简单了。数据结构基本操作啦。</p>
<p>迭代的做法，用动画更容易理解。先建一个假节点 <code class="docutils literal notranslate"><span class="pre">sentinel</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sentinel</span> <span class="o">-&gt;</span> <span class="n">null</span>
</pre></div>
</div>
<p>然后每次都从原链表抽出最前面的第一个节点，插入到 <code class="docutils literal notranslate"><span class="pre">sentinel</span></code> 的后面。比如 <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5</span></code> 的话，就先抽出 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，插入到 <code class="docutils literal notranslate"><span class="pre">sentinel</span></code> 后面</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sentinel</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">null</span>

<span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="n">null</span>
</pre></div>
</div>
<p>继续</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sentinel</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">null</span>

<span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="n">null</span>
</pre></div>
</div>
<p>继续</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sentinel</span> <span class="o">-&gt;</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">null</span>

<span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="n">null</span>
</pre></div>
</div>
<p>继续</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sentinel</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">null</span>

<span class="mi">5</span> <span class="o">-&gt;</span> <span class="n">null</span>
</pre></div>
</div>
<p>继续</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sentinel</span> <span class="o">-&gt;</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">null</span>

<span class="n">null</span>
</pre></div>
</div>
<p>结束，返回 <code class="docutils literal notranslate"><span class="pre">sentinel.next</span></code> 就好了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># 假节点</span>

            <span class="k">while</span> <span class="n">head</span><span class="p">:</span> <span class="c1"># 不停的抽出原链表的第一个节点，插入到sentinel的后面</span>
                <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="c1"># 原链表的第二个节点</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
                <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">newHead</span>

            <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>从链表里删除节点</h2>
<p><a class="reference external" href="https://leetcode.com/problems/delete-node-in-a-linked-list/">Leetcode 237</a></p>
<blockquote>
<div><p>给一个节点，不给你链表头，删掉那个节点。</p>
</div></blockquote>
<p>我一开始的想法是把这个节点后面的所有节点的值都顺次移到前面一个节点……看了答案发现不用这样，直接让当前的节点的值变成后面一个节点的值，然后把当前节点的 <code class="docutils literal notranslate"><span class="pre">next</span></code> 跨过后面一个节点、直接指向后面的后面一个节点就可以了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type node: ListNode</span>
<span class="sd">        :rtype: void Do not return anything, modify node in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">val</span>
        <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>二叉树的右视图</h2>
<p><a class="reference external" href="https://leetcode.com/problems/binary-tree-right-side-view/">Leetcode 199</a></p>
<blockquote>
<div><p>给一个二叉树，输出从二叉树的右边向左边看到的部分。</p>
</div></blockquote>
<p>把二叉树想成一个纸片，然后头在右边、眼睛向左看。</p>
<p>我记得这是三月我去加联创被问的题……然后我当时还没开始做树的题，没答出来，好尴尬。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 如果是最右边的节点</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>二叉树按层遍历</h2>
<p><a class="reference external" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Leetcode 102</a></p>
<p>不说了，每天都写。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">levelQueue</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">levelQueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                        <span class="n">levelQueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">])</span>
                <span class="n">queue</span> <span class="o">=</span> <span class="n">levelQueue</span>

            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="substring">
<h2>累加和最大的substring</h2>
<p><a class="reference external" href="https://leetcode.com/problems/maximum-subarray/">Leetcode 53</a></p>
<blockquote>
<div><p>给一个array，问其中累加和最大的substring（要连续）的累加和是多少？</p>
</div></blockquote>
<p>这种又是累加和又是substring的用prefix sum秒做。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">integrals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
        <span class="n">minIntegral</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 至今为止见到的最小的积分值</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">integrals</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span> <span class="p">]:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="n">minIntegral</span><span class="p">)</span> <span class="c1"># 以第i个元素结尾的累加和最大的substring的累加和是第i个积分值减去前面见过的最小的积分值</span>
            <span class="n">minIntegral</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minIntegral</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>二叉树中两个节点的最近公共祖先</h2>
<p><a class="reference external" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">Leetcode 236</a></p>
<blockquote>
<div><p>给一个二叉树、两个节点，找到这两个节点最近的公共祖先。</p>
</div></blockquote>
<p>我的做法是找到从root分别到两个节点的路径，然后两个路径diff一下，找到第一个不同的元素。</p>
<p>当然其实没必要做diff，可以把其中一个节点到根的路径上每个节点都存在hash set里，然后另一个节点顺着往上走，遇到的第一个在hash set里的祖宗就是这两个节点的公共节点。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">root</span><span class="p">:</span> <span class="n">root</span><span class="p">}</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                        <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                        <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

                <span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">size</span><span class="p">:</span> <span class="p">]</span>

            <span class="c1"># head = p</span>
            <span class="c1"># pathFromP = []</span>

            <span class="c1"># while head != graph[head]:</span>
            <span class="c1">#     pathFromP.append(head)</span>
            <span class="c1">#     head = graph[head]</span>

            <span class="c1"># pathFromP.append(root)</span>

            <span class="c1"># head = q</span>
            <span class="c1"># pathFromQ = []</span>

            <span class="c1"># while head != graph[head]:</span>
            <span class="c1">#     pathFromQ.append(head)</span>
            <span class="c1">#     head = graph[head]</span>

            <span class="c1"># pathFromQ.append(root)</span>

            <span class="c1"># pathToP = list(reversed(pathFromP))</span>
            <span class="c1"># pathToQ = list(reversed(pathFromQ))</span>

            <span class="c1"># for i in range(min(len(pathToP), len(pathToQ))):</span>
            <span class="c1">#     v = pathToP[i]</span>
            <span class="c1">#     w = pathToQ[i]</span>
            <span class="c1">#     if v != w:</span>
            <span class="c1">#         return pathToP[i - 1]</span>

            <span class="c1"># if len(pathToP) &lt;= len(pathToQ):</span>
            <span class="c1">#     return pathToP[-1]</span>
            <span class="c1"># else:</span>
            <span class="c1">#     return pathToQ[-1]</span>
            <span class="c1"># diff做法</span>

            <span class="n">nodesOnPathToP</span> <span class="o">=</span> <span class="p">{</span><span class="n">root</span><span class="p">}</span> <span class="c1"># 把root到p经过的所有节点都记下来</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">p</span>

            <span class="k">while</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">graph</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                <span class="n">nodesOnPathToP</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">head</span><span class="p">]</span>

            <span class="n">head</span> <span class="o">=</span> <span class="n">q</span>

            <span class="k">while</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">graph</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span> <span class="c1"># 然后从q开始顺着往上走</span>
                <span class="k">if</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">nodesOnPathToP</span><span class="p">:</span> <span class="c1"># 遇到的第一个也是p的祖宗的节点就是p和q最近的公共祖宗</span>
                    <span class="k">return</span> <span class="n">head</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 不是</span>
                    <span class="n">head</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="c1"># 继续往上翻家谱</span>

            <span class="k">return</span> <span class="n">root</span> <span class="c1"># 没找到，那只能是root了</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>判断某个值是否在排好序的矩阵里</h2>
<p><a class="reference external" href="https://leetcode.com/problems/search-a-2d-matrix-ii/">Leetcode 240</a></p>
<blockquote>
<div><p>有个性质非常好的矩阵：每行从左到右都是从小到大排列的、每列从上到下也是从小到大排好序的。快速判断某个值是否在这个矩阵里。</p>
</div></blockquote>
<p>比如给</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left(\begin{matrix}
    1 &amp; 4 &amp; 7 &amp; 11 &amp; 15 \\
    2 &amp; 5 &amp; 8 &amp; 12 &amp; 19 \\
    3 &amp; 6 &amp; 9 &amp; 16 &amp; 22 \\
    10 &amp; 13 &amp; 14 &amp; 17 &amp; 24 \\
    18 &amp; 21 &amp; 23 &amp; 26 &amp; 30 \\
\end{matrix}\right)\end{split}\]</div>
<p>要快速判断出 <code class="docutils literal notranslate"><span class="pre">5</span></code> 在里面、 <code class="docutils literal notranslate"><span class="pre">20</span></code> 不在里面。</p>
<p>官方解答讲的天花乱坠，我也不整那些有的没的了，一行一行遍历，如果发现要找的数有可能在这一行里，就在这一行里二分搜索一下。复杂度顶破天也就是 <span class="math notranslate nohighlight">\(O(m \ln n)\)</span> 。最坏情况每行都二分，也不亏。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>开个脑洞，如果这个矩阵是个瘦长的矩阵，就是 <span class="math notranslate nohighlight">\(m &gt; n\)</span> 的话，是不是可以想办法先把矩阵转置一下，变成一个矮胖的矩阵？这样复杂度就从 <span class="math notranslate nohighlight">\(O(m \ln n)\)</span> 变成 <span class="math notranslate nohighlight">\(O(n \ln m)\)</span> ，又省了一点了。</p>
</div>
<p>有两个小优化。第一个小优化是，一旦发现这一行的第一个数都比target大，那么没必要找下去了，为什么呢？</p>
<ul class="simple">
<li><p>首先target不可能出现在这一行了</p></li>
<li><p>之后的所有行，行首的第一个数只会越来越大，所以target也不可能出现在这一行之后的所有行了</p></li>
</ul>
<p>另一个小优化是，如果发现这一行最后一个数比target小，那么直接略过这一行，往下一行去就完事儿了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>


<span class="kn">import</span> <span class="nn">bisect</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">searchMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type matrix: List[List[int]]</span>
<span class="sd">        :type target: int</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>顺便如果要手写二分搜索的话，回忆一下定位最左边、最右边的代码，直接从 <a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">维基百科</a> 抄过来。</p>
<p>定位最左边的 <strong>插入位置</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

<span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># 顺便这里可能会问你溢出怎么办，改成left + (right - left) // 2就好了。不过反正python根本没有溢出</span>
    <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>

<span class="k">return</span> <span class="n">left</span>
</pre></div>
</div>
<p>定位最右边的 <strong>插入位置</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

<span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">return</span> <span class="n">right</span>
<span class="c1"># 维基上是return right - 1，但是我想找插入位置</span>
</pre></div>
</div>
<p>这样不太好记， <code class="docutils literal notranslate"><span class="pre">if</span></code> 的两个臂交换位置了，不如</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

<span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>

<span class="k">return</span> <span class="n">right</span>
</pre></div>
</div>
<p>但还是要记着一个是小于一个是大于，还是不太好记。</p>
<p>分析一下，定位最左和定位最右的区别只有两处</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">array[middle]</span> <span class="pre">==</span> <span class="pre">target</span></code> 的时候，定位最左是让 <code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">middle</span></code> ，定位最右是让 <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">middle</span> <span class="pre">+</span> <span class="pre">1</span></code></p></li>
<li><p>最后返回插入位置的时候，定位最左是 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">left</span></code> ，定位最右是 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">right</span></code></p></li>
</ul>
<p>所以不如把 <code class="docutils literal notranslate"><span class="pre">array[middle]</span> <span class="pre">==</span> <span class="pre">target</span></code> 的情况单独拿出来。不谈了，这是终极版，Python的 <code class="docutils literal notranslate"><span class="pre">bisect</span></code> 库 <a class="reference external" href="https://github.com/python/cpython/blob/master/Lib/bisect.py">也是这么写的</a> 。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bisectLeft</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>
        <span class="k">elif</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>

    <span class="k">return</span> <span class="n">left</span>

<span class="k">def</span> <span class="nf">bisectRight</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 区别</span>
        <span class="k">elif</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>

    <span class="k">return</span> <span class="n">right</span> <span class="c1"># 这里left、right都行，反正相等</span>
</pre></div>
</div>
<p>看了篇 <a class="reference external" href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie">神文</a> ，讲的巨好。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>我甚至还想给 <code class="docutils literal notranslate"><span class="pre">bisect</span></code> 加上自定义key function的功能。不知道为什么这个功能一直没有加入 <code class="docutils literal notranslate"><span class="pre">bisect</span></code> 。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bisectLeft</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span>

    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="o">==</span> <span class="n">key</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span> <span class="c1"># 区别</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span>

    <span class="k">return</span> <span class="n">left</span> <span class="c1"># 这里left、right都行，反正相等</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h2>验证括号嵌套</h2>
<p><a class="reference external" href="https://leetcode.com/problems/valid-parentheses/">Leetcode 20</a></p>
<blockquote>
<div><p>给一些由 <code class="docutils literal notranslate"><span class="pre">(,</span> <span class="pre">),</span> <span class="pre">[,</span> <span class="pre">],</span> <span class="pre">{,</span> <span class="pre">}</span></code> 组成的字符串，问你这个字符串符不符合括号嵌套规则。</p>
</div></blockquote>
<p>所谓括号嵌套规则我也说不清，大概就是括号成不成对的意思吧。比如</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">()[]{}</span>
</pre></div>
</div>
<p>成对，但是</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">([)]</span>
</pre></div>
</div>
<p>不成对。</p>
<p>这题是stack的经典应用。但是我说不清这题为什么用stack能解决。 <a class="footnote-reference brackets" href="#stack" id="id17">2</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">rightLeftMapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;]&quot;</span><span class="p">:</span> <span class="s2">&quot;[&quot;</span><span class="p">,</span>
            <span class="s2">&quot;)&quot;</span><span class="p">:</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span>
            <span class="s2">&quot;}&quot;</span><span class="p">:</span> <span class="s2">&quot;{&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="s2">&quot;([{&quot;</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">rightLeftMapping</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="stack"><span class="brackets"><a class="fn-backref" href="#id17">2</a></span></dt>
<dd><p>我对stack、queue这些真的理解不够深入，很多时候答案给我我都看不懂。大概是没上过数据结构的原因。</p>
</dd>
</dl>
</div>
<div class="section" id="id18">
<h2>给颜色排序</h2>
<p><a class="reference external" href="https://leetcode.com/problems/sort-colors/">Leetcode 75</a></p>
<blockquote>
<div><p>不用额外空间，给只含有 <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2</span></code> 的array排序。</p>
</div></blockquote>
<p>感觉像是 <a class="reference internal" href="#array0">把array里所有的0都移动到最后</a> 的翻版诶……先把所有的1移动到后面、再把所有的2移动到后面。要扫两遍，第一遍扫1，第二遍扫2。</p>
<p>这样做也挺快的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortColors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify nums in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>但是题目说还有只要扫描一遍就可以的做法。我仔细想了下，竟然也能想到。</p>
<p>像 <a class="reference internal" href="#array0">把array里所有的0都移动到最后</a> 里面，水滴里面只有 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，但是其实最多可以有2种元素的，像这道题里，水滴里可以有 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2</span></code> 。在水滴内部， <code class="docutils literal notranslate"><span class="pre">1</span></code> 永远在前面、 <code class="docutils literal notranslate"><span class="pre">2</span></code> 永远在后面，也就是说，水滴在往右边移动的过程，遇到 <code class="docutils literal notranslate"><span class="pre">0</span></code> 放到水滴外面的左边，遇到 <code class="docutils literal notranslate"><span class="pre">1</span></code> 放到水滴里面的左边，遇到 <code class="docutils literal notranslate"><span class="pre">2</span></code> 放到水滴里面的右边。这样水滴移动到最右的时候，水滴外面的左边全是 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，而水滴内部的左半边全是 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，右边全是 <code class="docutils literal notranslate"><span class="pre">2</span></code> ，也就间接达到了排序的目的了。</p>
<p>一开始我想改造上面的做法，还是只用两个指针 <code class="docutils literal notranslate"><span class="pre">left,</span> <span class="pre">right</span></code> ，但是纸上试了一下发现不行，还需要另一个指针，来表示水滴内部 <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2</span></code> 的分界点，就叫 <code class="docutils literal notranslate"><span class="pre">middle</span></code> 吧。</p>
<p>比如</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="o">|</span>               <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
<span class="o">|</span>               <span class="n">middle</span>
</pre></div>
</div>
<p>一开始 <code class="docutils literal notranslate"><span class="pre">left,</span> <span class="pre">middle,</span> <span class="pre">right</span></code> 全都在0处，右边是 <code class="docutils literal notranslate"><span class="pre">2</span></code> ，所以要吸收到水滴里面来，而且是放在水滴的右半部分</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="o">|</span> <span class="o">|</span>
<span class="o">|</span>
</pre></div>
</div>
<p>右边是 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，要排除到水滴外面，放在水滴外面的左边。怎么办呢？直接交换 <code class="docutils literal notranslate"><span class="pre">array[left],</span> <span class="pre">array[right]</span></code> 就好了嘛，交换完之后，水滴整体往右移动，也就是三个指针同时往右移动1格</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="o">|</span> <span class="o">|</span>
 <span class="o">|</span>
</pre></div>
</div>
<p>现在右边又遇到了 <code class="docutils literal notranslate"><span class="pre">2</span></code> ，吸收到水滴内部的右半边，所以直接 <code class="docutils literal notranslate"><span class="pre">right</span></code> 右移一格就可以了</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="o">|</span>   <span class="o">|</span>
 <span class="o">|</span>
</pre></div>
</div>
<p>右边遇到了 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，吸收到水滴内部的左半边，同样是交换 <code class="docutils literal notranslate"><span class="pre">array[right],</span> <span class="pre">array]left]</span></code> ，但是水滴内部出现了 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的部分，所以 <code class="docutils literal notranslate"><span class="pre">middle</span></code> 也要往右移动一格；水滴变大了， <code class="docutils literal notranslate"><span class="pre">right</span></code> 也要右移</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="o">|</span>     <span class="o">|</span>
   <span class="o">|</span>
</pre></div>
</div>
<p>还是遇到了 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，还是按刚才同样的操作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">0</span>
 <span class="o">|</span>       <span class="o">|</span>
     <span class="o">|</span>
</pre></div>
</div>
<p>遇到了 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，而且水滴内部既有 <code class="docutils literal notranslate"><span class="pre">1</span></code> 也有 <code class="docutils literal notranslate"><span class="pre">2</span></code> ，这是最麻烦的一种情况，不过也麻烦不到哪里去，需要轮换 <code class="docutils literal notranslate"><span class="pre">array[left],</span> <span class="pre">array[middle],</span> <span class="pre">array[right]</span></code> 。</p>
<p>啥叫轮换呢，就是</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</pre></div>
</div>
<p>变成</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span>
</pre></div>
</div>
<p>这样变成了</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span>
   <span class="o">|</span>       <span class="o">|</span>
       <span class="o">|</span>
</pre></div>
</div>
<p>搞定了！</p>
<p>我居然也能自己想出算法来了，膨胀了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortColors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify nums in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span> <span class="o">==</span> <span class="n">middle</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">left</span> <span class="o">==</span> <span class="n">middle</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">middle</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># left &lt; middle &lt; right</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span>

                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">middle</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span> <span class="o">==</span> <span class="n">middle</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">left</span> <span class="o">==</span> <span class="n">middle</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">middle</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># left &lt; middle &lt; right</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span>

                <span class="n">middle</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>遇到 <code class="docutils literal notranslate"><span class="pre">0</span></code> 就把这行这列全设成 <code class="docutils literal notranslate"><span class="pre">0</span></code></h2>
<p><a class="reference external" href="https://leetcode.com/problems/set-matrix-zeroes/">Leetcode 73</a></p>
<blockquote>
<div><p>给一个矩阵，把所有 <code class="docutils literal notranslate"><span class="pre">0</span></code> 出现的那一整行、一整列全部变成 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p>
</div></blockquote>
<p>看上去挺简单的啊，遍历一遍，把所有需要置 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的行号、列号记下来，然后再设置就好了。</p>
<p>但是问题下面有个要求是要用 <span class="math notranslate nohighlight">\(O(1)\)</span> 空间，那如果我们这样做的话，用的空间是 <span class="math notranslate nohighlight">\(O(m + n)\)</span> 。</p>
<p>看了答案大概懂了，写了个类似的，但没他那么精炼。</p>
<p>原理就是，像excel或者pandas的表格一样，把矩阵的最左边一列当做是index、最上面一行当做是column（如果你用过pandas应该会理解我说的），最左边一列用来标记这一行是否需要全部涂0，最上面一行用来标记这一列是否需要全部涂0。</p>
<div class="figure align-default" id="id29">
<img alt="../../_images/73.svg" src="../../_images/73.svg" /><p class="caption"><span class="caption-number">图 3 </span><span class="caption-text">这一行第一个如果是0，表示这行全部涂0。同理如果这一列第一个如果是0，表示这列全部涂0。</span></p>
</div>
<p>那第一行、第一列本身怎么处理？需要特殊处理。不过也很简单，先扫第一行，如果发现第一行有 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，就记下；扫第一列，如果发现有 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，也记下。等到中间的全部搞好了，最后再来处理第一行和第一列。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">setZeroes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify matrix in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rowCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">columnCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># 第一行特殊处理</span>
        <span class="n">firstRowClear</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">firstRowClear</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># 第一列特殊处理</span>
        <span class="n">firstColumnClear</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">):</span>
            <span class="n">firstColumnClear</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">for</span> <span class="n">rowIndex</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">columnIndex</span><span class="p">,</span> <span class="n">box</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">box</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 遇到某个0</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">rowIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 把这行最开头设置成0</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">columnIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 把这列最开头设置成0</span>

        <span class="k">for</span> <span class="n">rowIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rowCount</span><span class="p">):</span> <span class="c1"># 从第1行开始</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">rowIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 如果这一行的第一个元素是0</span>

                <span class="k">for</span> <span class="n">columnIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columnCount</span><span class="p">):</span> <span class="c1"># 整行清零</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">rowIndex</span><span class="p">][</span><span class="n">columnIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">columnIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">columnCount</span><span class="p">):</span> <span class="c1"># 从第1列开始</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">columnIndex</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 如果这一列的第一个元素是0</span>

                <span class="k">for</span> <span class="n">rowIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowCount</span><span class="p">):</span> <span class="c1"># 整列清零</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">rowIndex</span><span class="p">][</span><span class="n">columnIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 中间完成之后，再特殊处理第一列和第一行</span>
        <span class="k">if</span> <span class="n">firstColumnClear</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">rowIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowCount</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">rowIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">firstRowClear</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">columnIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columnCount</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">columnIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>列出所有组合</h2>
<p><a class="reference external" href="https://leetcode.com/problems/permutations/">Leetcode 46</a></p>
<blockquote>
<div><p>给一些不相同的数，输出这些数所有可能的排列组合。</p>
</div></blockquote>
<p>比如给 <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3</span></code> ，输出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span>
<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
<span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span>
<span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>
</div>
<p>差不多就是实现 <code class="docutils literal notranslate"><span class="pre">itertools.permutations()</span></code> 的感觉。</p>
</div>
<div class="section" id="array">
<h2>整个array除了自己的以外的积</h2>
<p><a class="reference external" href="https://leetcode.com/problems/product-of-array-except-self/">Leetcode 238</a></p>
<blockquote>
<div><p>给一个array，对其中每个元素 <span class="math notranslate nohighlight">\(a_i\)</span> 都计算出整个array除了 <span class="math notranslate nohighlight">\(a_i\)</span> 以外的那个subsequence的积。</p>
</div></blockquote>
<p>类似前缀和，只不过不是累加 <strong>和</strong> ，而是累加 <strong>积</strong> 。假设</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">productBefore[i]</span></code> 表示 <span class="math notranslate nohighlight">\(a_0 a_1 \cdots a_{i - 1}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">productAfter[i]</span></code> 表示 <span class="math notranslate nohighlight">\(a_i a_{i + 1} \cdots a_{n - 1}\)</span></p></li>
</ul>
<p>那么第 <span class="math notranslate nohighlight">\(i\)</span> 个元素的结果就是 <code class="docutils literal notranslate"><span class="pre">productBefore[i]</span> <span class="pre">*</span> <span class="pre">productAfter[i</span> <span class="pre">+</span> <span class="pre">1]</span></code> 。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">productBefore</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">productBefore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">productBefore</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">productAfter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">productAfter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">productAfter</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">productAfter</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">productBefore</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">productAfter</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
<p>Python只提供了累加和的函数 <code class="docutils literal notranslate"><span class="pre">itertools.accumulate()</span></code> 没有提供累加积的。Rust啥也没提供，提供了一个叫 <code class="docutils literal notranslate"><span class="pre">Iterator.scan()</span></code> 的 <a class="reference external" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan">函数</a> 。</p>
<p>题目还说只能用 <span class="math notranslate nohighlight">\(O(1)\)</span> 空间（不包括输出占用的空间）。那怎么究极省空间呢？我觉得可以先把 <code class="docutils literal notranslate"><span class="pre">productAfter</span></code> 整个算出来，放在输出里，然后再一边遍历一边算 <code class="docutils literal notranslate"><span class="pre">productBefore[i]</span></code> 、顺便覆盖输出。这样自始至终就只需要输出空间了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">productAfter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">productAfter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">productAfter</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">productAfter</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">productBefore</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 其实不需要得到每个productBefore[i]，只需要前一项就够了</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">productAfter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">productBefore</span> <span class="o">*</span> <span class="n">productAfter</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># 一边遍历一遍覆盖</span>
            <span class="n">productBefore</span> <span class="o">=</span> <span class="n">productBefore</span> <span class="o">*</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">productAfter</span><span class="p">[:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 最后一个是1，不用返回</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h2>合并几个排好序的链表</h2>
<p><a class="reference external" href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode 23</a></p>
<blockquote>
<div><p>给几个从小到大排好序的链表，合并成一个大链表。</p>
</div></blockquote>
<p>这个是merge sort里的其中一步。用分治法，两个两个合并，最后合并成一个大链表，这样复杂度是 <span class="math notranslate nohighlight">\(O(n \ln k)\)</span> ， <span class="math notranslate nohighlight">\(k\)</span> 是有多少个链表， <span class="math notranslate nohighlight">\(n\)</span> 是链表的长度。</p>
<p>看上去很简单，但是里面需要处理的细节巨多，比如</p>
<ul class="simple">
<li><p>万一 <code class="docutils literal notranslate"><span class="pre">lists</span></code> 是空的怎么办？</p></li>
<li><p>万一 <code class="docutils literal notranslate"><span class="pre">lists</span></code> 里面有空链表怎么办？</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="c1"># 删掉所有空链表</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># 发现空链表</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># 就和最后一个交换</span>
                <span class="n">lists</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 然后删掉</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">lists</span><span class="p">:</span> <span class="c1"># 如果没有链表了</span>
            <span class="k">return</span> <span class="bp">None</span> <span class="c1"># 直接返回</span>

        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 直到合并成一个大链表为止</span>
            <span class="n">newLists</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">newLists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merge2LinkedLists</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newLists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">lists</span> <span class="o">=</span> <span class="n">newLists</span>

        <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">merge2LinkedLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">list2</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">list1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list2</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">list2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list1</span>

        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span>

        <span class="k">while</span> <span class="n">list1</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">list2</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">list1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">list2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>
                <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>
                <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">list1</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>

        <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
<div class="section" id="sum">
<h2>3 sum</h2>
<p><a class="reference external" href="https://leetcode.com/problems/3sum/">Leetcode 15</a></p>
<blockquote>
<div><p>给一个array，输出所有 <span class="math notranslate nohighlight">\(a_i, a_j, a_k\)</span> ， <span class="math notranslate nohighlight">\(i &lt; j &lt; k\)</span> ，使得 <span class="math notranslate nohighlight">\(a_i + a_j + a_k = t\)</span> 。</p>
</div></blockquote>
<p>归约到2 sum。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="c1"># 咕咕</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h2>面试体验</h2>
<p>2020/3/11下午面的。到现在也没理我约二面，所以大概是凉了吧……</p>
<p>问了一道桶排序。很尴尬的是我忘了这个叫桶排序，不停地说这个count and say……好在代码2 min就写出来了。然后问我复杂度是多少。</p>
<p>然后问了一道房间找钥匙的题目，也是 <a class="reference external" href="https://leetcode.com/problems/keys-and-rooms">原题</a> ，我有印象，而且周赛貌似出现过类似的，前几周刚刚 <a class="reference external" href="https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/">做过</a> ，所以也是直接BFS几分钟就写出来了。</p>
<p>这两题过去了我感觉非常良好……然后就开始作死了，被问了一道二叉树preorder的非递归写法。这个我会！面试之前特意看了一下，啊啊啊啊，太好了。用stack秒做。</p>
<p>然后就开始尴尬了，小姐姐问我那postorder的非递归怎么写……这里卡了15 min，最后我终于发现postorder可以通过preorder稍加改动 <a class="footnote-reference brackets" href="#id27" id="id26">3</a> 、最后整体颠倒。</p>
<p>不知道什么时候二面呢……</p>
<p>2020/3/23</p>
<dl class="footnote brackets">
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id26">3</a></span></dt>
<dd><p>原来preorder里面，stack是先放right、再放left，改成先放left、再放right。</p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">PayPal题库</a><ul>
<li><a class="reference internal" href="#id2">机器人出不出圈</a></li>
<li><a class="reference internal" href="#zigzag">按ZigZag顺序格式化字符串</a></li>
<li><a class="reference internal" href="#id3">两个元素下标的最小距离</a></li>
<li><a class="reference internal" href="#two-sum">Two sum</a></li>
<li><a class="reference internal" href="#lru">实现LRU缓存</a></li>
<li><a class="reference internal" href="#id4">螺旋遍历矩阵</a></li>
<li><a class="reference internal" href="#id5">两个词是否是颠倒字母顺序形成的</a></li>
<li><a class="reference internal" href="#k">数列里有多少对差的绝对值正好是 <span class="math notranslate nohighlight">\(k\)</span> 的数对</a></li>
<li><a class="reference internal" href="#peek">实现支持 <code class="docutils literal notranslate"><span class="pre">peek()</span></code> 的迭代器</a></li>
<li><a class="reference internal" href="#subsequence-sum">Subsequence sum</a></li>
<li><a class="reference internal" href="#array0">把array里所有的0都移动到最后</a></li>
<li><a class="reference internal" href="#k-k"><span class="math notranslate nohighlight">\(k\)</span> 个 <span class="math notranslate nohighlight">\(k\)</span> 个颠倒链表</a></li>
<li><a class="reference internal" href="#id7">颠倒链表</a></li>
<li><a class="reference internal" href="#id8">从链表里删除节点</a></li>
<li><a class="reference internal" href="#id9">二叉树的右视图</a></li>
<li><a class="reference internal" href="#id10">二叉树按层遍历</a></li>
<li><a class="reference internal" href="#substring">累加和最大的substring</a></li>
<li><a class="reference internal" href="#id11">二叉树中两个节点的最近公共祖先</a></li>
<li><a class="reference internal" href="#id12">判断某个值是否在排好序的矩阵里</a></li>
<li><a class="reference internal" href="#id16">验证括号嵌套</a></li>
<li><a class="reference internal" href="#id18">给颜色排序</a></li>
<li><a class="reference internal" href="#id19">遇到 <code class="docutils literal notranslate"><span class="pre">0</span></code> 就把这行这列全设成 <code class="docutils literal notranslate"><span class="pre">0</span></code></a></li>
<li><a class="reference internal" href="#id20">列出所有组合</a></li>
<li><a class="reference internal" href="#array">整个array除了自己的以外的积</a></li>
<li><a class="reference internal" href="#id22">合并几个排好序的链表</a></li>
<li><a class="reference internal" href="#sum">3 sum</a></li>
<li><a class="reference internal" href="#id23">面试体验</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../prefix-sum/index.html"
                        title="上一章">前缀和太好用了</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="../mathworks-interview/index.html"
                        title="下一章">MathWorks题库</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/posts/paypal-interview/index.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../mathworks-interview/index.html" title="MathWorks题库"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../prefix-sum/index.html" title="前缀和太好用了"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">blog  文档</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, aiifabbf.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2 创建。
    </div>
  </body>
</html>