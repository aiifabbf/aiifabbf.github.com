
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>Amazon题库 &#8212; blog  文档</title>
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">blog  文档</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="amazon">
<h1><a class="toc-backref" href="#id27">Amazon题库</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#amazon" id="id27">Amazon题库</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id28">二叉树的最大深度</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id29">二叉树是否是另一棵二叉树的子树</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id30">一组一组地颠倒链表</a></p></li>
<li><p><a class="reference internal" href="#x-n" id="id31">不使用内建函数实现 <span class="math notranslate nohighlight">\(x^n\)</span></a></p></li>
<li><p><a class="reference internal" href="#id6" id="id32">垂直遍历二叉树</a></p></li>
<li><p><a class="reference internal" href="#sum" id="id33">2 sum</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id34">竖式加法</a></p></li>
<li><p><a class="reference internal" href="#lru" id="id35">实现LRU缓存</a></p></li>
<li><p><a class="reference internal" href="#substring" id="id36">最长回文substring</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id37">岛屿的数量</a></p></li>
<li><p><a class="reference internal" href="#lfu" id="id38">实现LFU缓存</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id39">关键通路</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id40">验证括号嵌套</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id41">合并两个排好序的链表</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id42">合并多个排好序的链表</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id43">排序两种日志字符串</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id44">链表深复制</a></p></li>
<li><p><a class="reference internal" href="#id19" id="id45">整数的英文说法</a></p></li>
<li><p><a class="reference internal" href="#id20" id="id46">序列化和反序列化二叉树</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id47">最少需要多少间会议室</a></p></li>
<li><p><a class="reference internal" href="#k" id="id48">离原点最近的 <span class="math notranslate nohighlight">\(k\)</span> 个点</a></p></li>
<li><p><a class="reference internal" href="#id24" id="id49">乱序字符分组</a></p></li>
<li><p><a class="reference internal" href="#o-1" id="id50">设计插入、删除、随机选取都是 <span class="math notranslate nohighlight">\(O(1)\)</span> 的数据结构</a></p></li>
<li><p><a class="reference internal" href="#id25" id="id51">二叉树中最大路径和</a></p></li>
<li><p><a class="reference internal" href="#id26" id="id52">嵌套列表降维</a></p></li>
</ul>
</li>
</ul>
</div>
<p>今天开始一道一道刷Amazon的面试题吧！题目列表是从 <a class="reference external" href="https://1o24bbs.com/t/topic/12368">这里</a> 找的，不知道准不准。</p>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id28">二叉树的最大深度</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Leetcode 104</a></p>
<blockquote>
<div><p>给一个二叉树，这个二叉树有几层？</p>
</div></blockquote>
<p>这也太简单了，按层遍历一波带走</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">depth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id29">二叉树是否是另一棵二叉树的子树</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/subtree-of-another-tree/">Leetcode 572</a></p>
<blockquote>
<div><p>给两个二叉树 <code class="docutils literal notranslate"><span class="pre">s,</span> <span class="pre">t</span></code> ， <code class="docutils literal notranslate"><span class="pre">t</span></code> 是否是 <code class="docutils literal notranslate"><span class="pre">s</span></code> 的子树？</p>
</div></blockquote>
<p>遍历 <code class="docutils literal notranslate"><span class="pre">s</span></code> 的每个子树，看有没有哪个子树和 <code class="docutils literal notranslate"><span class="pre">t</span></code> 相等就好了。</p>
<p>首先要写一个helper function，判断两个二叉树是否是相等。很简单，用递归写就好了</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isEqualTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">isEqualTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isEqualTree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isEqualTree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id30">一组一组地颠倒链表</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode 25</a></p>
<blockquote>
<div><p>给一个链表，每次数 <span class="math notranslate nohighlight">\(k\)</span> 个元素，颠倒一下。如果到最后不满 <span class="math notranslate nohighlight">\(k\)</span> 个，就不动。</p>
</div></blockquote>
<p>比如</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>
</div>
<ul class="simple">
<li><p>如果 <span class="math notranslate nohighlight">\(k = 2\)</span> ，那么结果是 <code class="docutils literal notranslate"><span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">4,</span> <span class="pre">3,</span> <span class="pre">5</span></code></p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(k = 3\)</span> ，那么结果是 <code class="docutils literal notranslate"><span class="pre">3,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">4,</span> <span class="pre">5</span></code></p></li>
</ul>
<p>如果我自己写，很简单，我肯定先把链表转换成List，然后做颠倒，然后再转换回来。但是这道题要求常数空间，所以就不能这么做了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseKGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        
</pre></div>
</div>
</div>
<div class="section" id="x-n">
<h2><a class="toc-backref" href="#id31">不使用内建函数实现 <span class="math notranslate nohighlight">\(x^n\)</span></a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/powx-n/">Leetcode 50</a></p>
<p>注意 <span class="math notranslate nohighlight">\(n\)</span> 可能是是负数哦。</p>
<p>分情况讨论吧</p>
<ul>
<li><p>如果 <span class="math notranslate nohighlight">\(x = 0\)</span></p>
<ul class="simple">
<li><p>并且 <span class="math notranslate nohighlight">\(n = 0\)</span> ，那么未定义</p></li>
<li><p>否则就是0</p></li>
</ul>
</li>
<li><p>如果 <span class="math notranslate nohighlight">\(x \neq 0\)</span></p>
<ul>
<li><p>如果 <span class="math notranslate nohighlight">\(n = 0\)</span> ，那么是1</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(n &lt; 0\)</span> ，那么是 <span class="math notranslate nohighlight">\({1 \over x^{-n}}\)</span></p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(n &gt; 0\)</span> 并且是个偶数，那么做一下转换</p>
<div class="math notranslate nohighlight">
\[x^n = x^{2 \cdot {n \over 2}} = (x^2)^{n \over 2}\]</div>
</li>
<li><p>如果 <span class="math notranslate nohighlight">\(n &gt; 0\)</span> 并且是个奇数，那么 <span class="math notranslate nohighlight">\(n - 1\)</span> 就是偶数了啊</p>
<div class="math notranslate nohighlight">
\[x^n = x^{1 + (n - 1)} = x \cdot x^{n - 1}\]</div>
</li>
</ul>
</li>
</ul>
<p>注意Python虽然int不会overflow，但是float会overflow……这点真的好奇怪。</p>
<p>而且 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code> 效果还不一样啊！ <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">2</span></code> 可能会overflow但是 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code> 就不会overflow。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">myPow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPow</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># 很奇怪，我也不知道为什么这里用x * x就不会overflow，但是用x ** 2就会overflow</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id32">垂直遍历二叉树</a></h2>
<p>这道是人民币玩家才能做的……</p>
<hr class="docutils" />
<p>我还是先把最高频的50道做完吧_(:з」∠)_</p>
</div>
<div class="section" id="sum">
<h2><a class="toc-backref" href="#id33">2 sum</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/two-sum/">Leetcode 1</a></p>
<p>这个说烂了。</p>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id34">竖式加法</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/add-two-numbers/">Leetcode 2</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">l1</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">l2</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">summation</span> <span class="o">=</span> <span class="n">carry</span>
            <span class="k">if</span> <span class="n">l1</span><span class="p">:</span>
                <span class="n">summation</span> <span class="o">+=</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">l2</span><span class="p">:</span>
                <span class="n">summation</span> <span class="o">+=</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>

            <span class="k">if</span> <span class="n">summation</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">summation</span> <span class="o">-=</span> <span class="mi">10</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">summation</span><span class="p">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
<div class="section" id="lru">
<h2><a class="toc-backref" href="#id35">实现LRU缓存</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/lru-cache/">Leetcode 146</a></p>
<p>用linked list和hash map实现。</p>
<p>根本矛盾是</p>
<ul class="simple">
<li><p>linked list可以保存顺序信息，但是没法做到 <span class="math notranslate nohighlight">\(O(1)\)</span> 访问任意一个节点</p></li>
<li><p>hash map可以做到 <span class="math notranslate nohighlight">\(O(1)\)</span> 访问，但是没法保存顺序信息</p></li>
</ul>
<p>所以这两个是互补的，同时用它们，就可以做到既能保存顺序信息、又能 <span class="math notranslate nohighlight">\(O(1)\)</span> 访问。怎么做呢？</p>
<ul class="simple">
<li><p>hash map的key存key，value不存value，存linked list里的节点的引用</p></li>
<li><p>linked list里的节点既存key又存value</p></li>
</ul>
<p>为什么要这么麻烦？你仔细想一下每个流程</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(O(1)\)</span> 判断key是否存在</p>
<p>可以用hash map做到</p>
</li>
<li><p><span class="math notranslate nohighlight">\(O(1)\)</span> 返回一个key对应的value</p>
<p>这个也可以用hash map做到</p>
</li>
<li><p>如果缓存满了，又要加入新的key，需要 <span class="math notranslate nohighlight">\(O(1)\)</span> 删除最远使用的key</p>
<p>这个绝对没问题，这样安排linked list：越靠左边的节点，代表越最近访问的key。linked list可以做到 <span class="math notranslate nohighlight">\(O(1)\)</span> 删除最后一个节点。</p>
<p>删除linked list里最后一个节点的时候，hash map里的条目也要跟着删除，可是linked list里面的节点里只存value，不知道对应的是hash map里的哪一个条目啊。</p>
<p>那就让linked list里面的节点不光要存value，也要存key就好了。</p>
</li>
<li><p>如果是访问一个缓存中已经存在的key，需要 <span class="math notranslate nohighlight">\(O(1)\)</span> 把那个key移动到最近</p>
<p>这个就有点难了，linked list并不能做到 <span class="math notranslate nohighlight">\(O(1)\)</span> 其中任意一个节点。</p>
<p>那怎么办？hash map可以做到啊，让hash map的不存value、而是存节点的引用不就好了？</p>
</li>
</ul>
<p>再次总结一下重点</p>
<ul class="simple">
<li><p>需要hash map和double linked list这是肯定的，我能想到</p></li>
<li><p>hash map的value存的是节点的引用，而不是value</p></li>
<li><p>linked list里面的节点存的是key和value</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DoubleLinkedListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># key是key，value不是value，而是节点的引用，不然做不到所有操作都是O(1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">DoubleLinkedListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># 头虚节点</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">DoubleLinkedListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># 尾虚节点</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">:</span> <span class="c1"># 缓存里存在这个key</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1"># 取出节点</span>
            <span class="c1"># 下面的操作是把节点取出来、放到linked list的最前面</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">previous</span> <span class="c1"># left先是节点的前面一个节点</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="c1"># right先是节点的后面一个节点</span>

            <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span> <span class="c1"># left直接指向right，绕过节点</span>
            <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span> <span class="c1"># right直接指向left，绕过节点</span>
            <span class="c1"># 这样节点就从list里删除了</span>
            <span class="c1"># 下面要把节点插入到最前面</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="c1"># left变成最前面的虚节点</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="c1"># right变成第一个节点</span>

            <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># left指向节点</span>
            <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">node</span> <span class="c1"># right指向节点</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span> <span class="c1"># 节点指向left</span>
            <span class="n">node</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span> <span class="c1"># 节点指向right</span>

            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">:</span> <span class="c1"># 如果key在缓存里面了</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1"># 先取一次，这样间接做到了把节点放到最前面</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="c1"># 再更新value的值</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 如果key不在缓存里面</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">:</span> <span class="c1"># 先看下缓存有没有满，如果满了，要先删掉linked list最后那个节点</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">previous</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">previous</span>
                <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>

                <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span>
                <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span>

                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># 建一个新节点，放到linked list的最前面</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">DoubleLinkedListNode</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>

            <span class="n">node</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span>

            <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">node</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

<span class="c1"># Your LRUCache object will be instantiated and called as such:</span>
<span class="c1"># obj = LRUCache(capacity)</span>
<span class="c1"># param_1 = obj.get(key)</span>
<span class="c1"># obj.put(key,value)</span>
</pre></div>
</div>
</div>
<div class="section" id="substring">
<h2><a class="toc-backref" href="#id36">最长回文substring</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode</a></p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id37">岛屿的数量</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/number-of-islands/">Leetcode</a></p>
<p>Union find基础题，不多说了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">rowCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">columnCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">rowIndex</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">columnIndex</span><span class="p">,</span> <span class="n">box</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">box</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">rowIndex</span><span class="p">,</span> <span class="n">columnIndex</span><span class="p">)</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">(</span><span class="n">rowIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">columnIndex</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">rowIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">columnIndex</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">rowIndex</span><span class="p">,</span> <span class="n">columnIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">rowIndex</span><span class="p">,</span> <span class="n">columnIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">]</span>

                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rowCount</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">columnCount</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                            <span class="n">mapping</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>
        
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">rootOfP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">rootOfQ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">rootOfP</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOfQ</span>

    <span class="k">def</span> <span class="nf">rootOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Type&quot;</span><span class="p">:</span>

        <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="lfu">
<h2><a class="toc-backref" href="#id38">实现LFU缓存</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/lfu-cache/">Leetcode</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DoubleLinkedListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">LFUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">DoubleLinkedListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">DoubleLinkedListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">previous</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>

            <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span>
            <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span>

            <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">previous</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">previous</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">next</span>

            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span>
            <span class="n">node</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">node</span>

            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">previous</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">previous</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>

                <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span>
                <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span>

                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">node</span> <span class="o">=</span> <span class="n">DoubleLinkedListNode</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">previous</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>

            <span class="n">left</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">right</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyNodeMapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="c1"># Your LFUCache object will be instantiated and called as such:</span>
<span class="c1"># obj = LFUCache(capacity)</span>
<span class="c1"># param_1 = obj.get(key)</span>
<span class="c1"># obj.put(key,value)</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id39">关键通路</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/critical-connections-in-a-network/">Leetcode</a></p>
<p>哇，这题很有意思的</p>
<blockquote>
<div><p>给一个无向无权图 <span class="math notranslate nohighlight">\(G = (V, E)\)</span> ，含有 <span class="math notranslate nohighlight">\(n\)</span> 个节点，起点是0号节点，终点是 <span class="math notranslate nohighlight">\(n - 1\)</span> 号节点。图中哪些边满足，仅仅就删掉这一条边之后，就没有办法从起点走到终点了呢？</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">criticalConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">connections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        
        
    <span class="k">def</span> <span class="nf">rootOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Type&quot;</span><span class="p">:</span>

        <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p</span>
    
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">rootOfP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">rootOfQ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">rootOfP</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOfQ</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootOf</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id40">验证括号嵌套</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/valid-parentheses/">Leetcode 20</a></p>
<p>简单的，用stack</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="s2">&quot;([{&quot;</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stack</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;]&quot;</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;}&quot;</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">stack</span> <span class="o">==</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2><a class="toc-backref" href="#id41">合并两个排好序的链表</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode 21</a></p>
<p>想象一下在你面前有两列从小到大排列好的扑克牌，你会怎么把它们合并成一个扑克牌呢？肯定是分别比较两列扑克牌的最前面、最小的那张，看哪个牌堆的第一张扑克牌小，取出来。如果某列扑克牌取完了，就直接把剩下的那一堆移动过来就好了。</p>
<p>这样写其实我不喜欢，我觉得改变了原来的链表，最好应该能生成一个新的。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span>

        <span class="k">while</span> <span class="n">l1</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">l2</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">l1</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>

        <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2><a class="toc-backref" href="#id42">合并多个排好序的链表</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode 23</a></p>
<p>我好怀疑这个题是不是上一题的follow-up，频率都离得这么近。</p>
<p>Merge sort里会用到这个函数。</p>
<p>做法是不停地两个两个合并（可以直接利用上一题的函数），直到最后只有一个linked list为止。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">lists</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">list1</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">list2</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merge2Lists</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">list1</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">list2</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merge2Lists</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>

                <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">merge2Lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span>

        <span class="k">while</span> <span class="n">l1</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">l2</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">l1</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>

        <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id43">排序两种日志字符串</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/reorder-data-in-log-files/">Leetcode 937</a></p>
<p>这个毫无难度。按照它说的做就好了。先把letter log和digit log分成两堆，然后用自定义key排序digit log，注意它说的</p>
<ul class="simple">
<li><p>先按identifier后面的排序</p></li>
<li><p>如果出现重复的，再按identifier后面的日志内容排序</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reorderLogFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">letterLogs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">digitLogs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">logs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">digitLogs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">letterLogs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">letterLogs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span> <span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">digitLogs</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id44">链表深复制</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/copy-list-with-random-pointer/">Leetcode</a></p>
<p>我的做法很简单，搞一个hash map，key是老节点，value是新节点。第一遍遍历把所有新节点对象都造好，第二遍遍历的时候利用hash map解决引用问题。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># Definition for a Node.</span>
<span class="sd">class Node:</span>
<span class="sd">    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):</span>
<span class="sd">        self.val = int(x)</span>
<span class="sd">        self.next = next</span>
<span class="sd">        self.random = random</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">copyRandomList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Node&#39;</span><span class="p">:</span>
        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">head</span> <span class="c1"># 保存好旧链表头</span>
        <span class="n">oldNewMapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">None</span><span class="p">:</span> <span class="bp">None</span>
        <span class="p">}</span> <span class="c1"># key是老节点，value是新节点</span>

        <span class="k">while</span> <span class="n">head</span><span class="p">:</span> <span class="c1"># 第一遍遍历</span>
            <span class="n">oldNewMapping</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c1"># 只要复制出新节点就行，先不要解决引用问题</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">sentinel</span>

        <span class="k">while</span> <span class="n">head</span><span class="p">:</span> <span class="c1"># 第二遍遍历，解决引用问题</span>
            <span class="n">oldNewMapping</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">oldNewMapping</span><span class="p">[</span><span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="p">]</span> <span class="c1"># 新节点的next指向旧节点next指向的那个节点对应的新节点</span>
            <span class="n">oldNewMapping</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="n">oldNewMapping</span><span class="p">[</span><span class="n">head</span><span class="o">.</span><span class="n">random</span><span class="p">]</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="c1"># 新节点的random指向旧节点random指向的那个节点对应的新节点</span>

        <span class="k">return</span> <span class="n">oldNewMapping</span><span class="p">[</span><span class="n">sentinel</span><span class="p">]</span> <span class="c1"># 返回head对应的新节点</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2><a class="toc-backref" href="#id45">整数的英文说法</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/integer-to-english-words/">Leetcode 273</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numberToWords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="p">]</span>
        <span class="n">thousands</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2><a class="toc-backref" href="#id46">序列化和反序列化二叉树</a></h2>
</div>
<div class="section" id="id21">
<h2><a class="toc-backref" href="#id47">最少需要多少间会议室</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/meeting-rooms-ii/">Leetcode</a></p>
<blockquote>
<div><p>给一些左闭右开的区间，代表会议的时间区间，至少需要多少间会议室？</p>
</div></blockquote>
<p>这个题目的 <a class="reference external" href="https://leetcode.com/problems/meeting-rooms">简单版本</a> 是</p>
<blockquote>
<div><p>给一些左闭右开区间，代表时间区间，这些时间区间是否两两之间都互相兼容、没有时间冲突？</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minMeetingRooms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">roomFinishingTimes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">roomFinishingTimes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">roomFinishingTimes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">roomFinishingTimes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">roomFinishingTimes</span><span class="p">)</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">roomFinishingTimes</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">roomFinishingTimes</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">roomFinishingTimes</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">roomFinishingTimes</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">minMeetingRooms</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]))</span> <span class="c1"># 2</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">minMeetingRooms</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]))</span> <span class="c1"># 1</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">minMeetingRooms</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">],[</span><span class="mi">36</span><span class="p">,</span><span class="mi">45</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">29</span><span class="p">],[</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]]))</span> <span class="c1"># 2</span>
</pre></div>
</div>
</div>
<div class="section" id="k">
<h2><a class="toc-backref" href="#id48">离原点最近的 <span class="math notranslate nohighlight">\(k\)</span> 个点</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/k-closest-points-to-origin/">Leetcode 973</a></p>
<p>太简单了吧……这种题怎么会高频考。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kClosest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)[:</span> <span class="n">K</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Solution</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">k_closest</span><span class="p">(</span><span class="n">points</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">k</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">points</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">cloned</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">points</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="o">|</span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">points</span><span class="p">[..</span><span class="n">k</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">].</span><span class="n">to_vec</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2><a class="toc-backref" href="#id49">乱序字符分组</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/group-anagrams/">Leetcode 49</a></p>
<blockquote>
<div><p>给一堆字符串，把anagram相同的都归到一组。</p>
</div></blockquote>
<p>如果两个字符串互为anagram，那么给它们按字典序排序之后得到相同的字符串。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">anagram</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">anagram</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">anagram</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">anagram</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="o-1">
<h2><a class="toc-backref" href="#id50">设计插入、删除、随机选取都是 <span class="math notranslate nohighlight">\(O(1)\)</span> 的数据结构</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Leetcode 380</a></p>
<p>这个真的太牛逼了，我看了答案觉得啧啧称奇，自己估计永远都没法想出来。</p>
<p>首先是插入和删除都要 <span class="math notranslate nohighlight">\(O(1)\)</span> 这个需求，很容易想到用hash set或者hash map。但是随机选取要 <span class="math notranslate nohighlight">\(O(1)\)</span> 这个需求用hash set和hash map是没法做到的，因为hash系列（hash set和hash map）都是无序的，而随机选取的本质是生成一个随机地址，然后选择那个随机地址上的内容。</p>
<p>有人说，那没问题啊，我先把hash map里所有的key都放在array list里面，再随机好不好啊？那这样把hash map转换成array list的复杂度就是 <span class="math notranslate nohighlight">\(O(n)\)</span> 了。不满足要求了。</p>
<p>所以这里需要用一下hash map和array list的结合，同时又要避免转换的过程。我想到了LRU那道题里面的做法。回忆一下LRU那道题，hash map里面存的是linked list里的node，node里面存的是key、value。</p>
<p>那么这里是不是也可以这样搞呢？可以啊，让hash map的key存题目里那个 <code class="docutils literal notranslate"><span class="pre">val</span></code> ，value存array list里key所在的下标，然后array list里再存key。想想这样是不是可以做到随机选取是 <span class="math notranslate nohighlight">\(O(1)\)</span> ？可以的，给随机数之后， <span class="math notranslate nohighlight">\(O(1)\)</span> 时间内能定位到array list的某一个元素，而这个元素正好是某个 <code class="docutils literal notranslate"><span class="pre">val</span></code> ，那不就是 <span class="math notranslate nohighlight">\(O(1)\)</span> 了吗？</p>
<p>插入的时候可以做到 <span class="math notranslate nohighlight">\(O(1)\)</span> 吗？可以的，直接在hash map里建一个新的条目，再在array list的最后追加一个元素 <code class="docutils literal notranslate"><span class="pre">val</span></code> ，让新条目的value指向这个元素（也就是存这个元素的下标）就好了。</p>
<p>但是问题是删除没法做到 <span class="math notranslate nohighlight">\(O(1)\)</span> 。我一开始的想法是，删除某个 <code class="docutils literal notranslate"><span class="pre">val</span></code> 的时候，只需要删掉hash map里对应的条目，array list里面的东西不管，随机选取的时候，如果抽中某个hash map不存在的 <code class="docutils literal notranslate"><span class="pre">val</span></code> 就再抽一次……这样有一个问题就是如果hash map里元素基本上都删掉了，随机选取就会很慢，因为总是抽到hash map里面没有的东西。</p>
<p>怎么解决这个问题呢？精妙的部分来了。删除的时候，array list里面的元素也是要跟着删除的，然而这里有一个矛盾，删除array list里的某个元素的复杂度是 <span class="math notranslate nohighlight">\(O(n)\)</span> ，因为假如你删的是最后一个元素，没问题，删掉就好了；假如不巧你删掉的是第一个元素，那么后面所有的元素都要往前顺位。</p>
<p>那我用linked list好不好？linked list虽然避免了删除 <span class="math notranslate nohighlight">\(O(n)\)</span> 的缺点，但是linked list没有随机访问的性质啊，访问linked list的第一个元素和最后一个元素的复杂度是不一样的，那么这样的话随机选取 <span class="math notranslate nohighlight">\(O(1)\)</span> 那个需求就没法满足了。</p>
<p>怎么办？刚才其实暗示过了，删除array list的最后一个元素是最快的，那我不如把我要删的那个元素和array list的最后一个元素调换一下位置。啥意思呢？假设我要删除的条目是 <code class="docutils literal notranslate"><span class="pre">(key1,</span> <span class="pre">value1)</span></code> ，array list的最后一个元素存的是 <code class="docutils literal notranslate"><span class="pre">key2</span></code> ，那么很简单，我调换一下 <code class="docutils literal notranslate"><span class="pre">value1,</span> <span class="pre">value2</span></code> ，两个条目变成</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">value2</span> <span class="n">指向array</span> <span class="n">list的最后一个元素</span>
<span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">value1</span><span class="p">)</span>
</pre></div>
</div>
<p>再让 <code class="docutils literal notranslate"><span class="pre">array[value1]</span> <span class="pre">=</span> <span class="pre">value1,</span> <span class="pre">array[value2]</span> <span class="pre">=</span> <span class="pre">value2</span></code> ，然后删掉hash map中的 <code class="docutils literal notranslate"><span class="pre">(key1,</span> <span class="pre">value2)</span></code> 和array list中的最后一个元素，是不是就好了？</p>
<p>简单画了一个图</p>
<div class="figure align-default">
<a class="reference internal image-reference" href="../../_images/leetcode-380.svg"><img alt="../../_images/leetcode-380.svg" src="../../_images/leetcode-380.svg" width="100%" /></a>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">class</span> <span class="nc">RandomizedSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize your data structure here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># key存val，value存val在array list中的下标</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 这就是那个array list，存的是val</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="c1"># 插入的时候比较简单</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">:</span> <span class="c1"># 如果本来就在里面</span>
            <span class="k">return</span> <span class="bp">False</span> <span class="c1"># 啥也不做</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 如果不在里面</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span> <span class="c1"># 开一个新的条目，key存val，value指向array list的最后一个格子</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1"># array list的最后建一个新的格子，存val</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="c1"># 删除的时候是最麻烦的</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a value from the set. Returns true if the set contained the specified element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">:</span> <span class="c1"># 如果val存在</span>
            <span class="n">thatValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 先看下array list的最后一个元素是什么</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">thatValue</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">thatValue</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="c1"># 调换一下两个条目的value</span>
            <span class="c1"># self.buffer[self.mapping[val]] = val # 没有必要更新这个条目的value指向的array list里那个格子里的元素，因为反正要删掉的</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">thatValue</span><span class="p">]]</span> <span class="o">=</span> <span class="n">thatValue</span> <span class="c1"># 更新一下那个条目的value指向的array list里那个格子里的元素</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 删掉array list的最后一个元素</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1"># 删掉hash map里对应的条目</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 如果val不存在</span>
            <span class="k">return</span> <span class="bp">False</span> <span class="c1"># 啥也不做</span>

    <span class="k">def</span> <span class="nf">getRandom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="c1"># 随机取也很简单</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a random element from the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 随机产生一个下标</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1"># 到array list里面去取那个下标的val</span>

<span class="c1"># Your RandomizedSet object will be instantiated and called as such:</span>
<span class="c1"># obj = RandomizedSet()</span>
<span class="c1"># param_1 = obj.insert(val)</span>
<span class="c1"># param_2 = obj.remove(val)</span>
<span class="c1"># param_3 = obj.getRandom()</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h2><a class="toc-backref" href="#id51">二叉树中最大路径和</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">Leetcode 124</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxPathSumPassingHere</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">maxPathSumStartingHere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">maxPathSumPassingHere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h2><a class="toc-backref" href="#id52">嵌套列表降维</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/flatten-nested-list-iterator/">Leetcode 341</a></p>
<p>就是把类似 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">[3]],</span> <span class="pre">[2,</span> <span class="pre">3]]</span></code> 这种东西展平成 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> 。</p>
<p>我自己做的话肯定是一下子就把整个列表弄出来存在那里，然后需要的时候一个一个吐出来。</p>
<p>但是面试的时候可能会叫你用online的方法，因为这样省内存。</p>
<p>想了很久，中间试过递归之类的办法，但是好像都不省内存。最后看了答案，发现超级简单。</p>
<p>用一个queue，每次 <code class="docutils literal notranslate"><span class="pre">hasNext()</span></code> 的时候，保证最前面的元素是integer就可以了。如果发现最前面的元素不是integer，就不停地展开，直到最前面的元素是integer为止。这样在 <code class="docutils literal notranslate"><span class="pre">next()</span></code> 的时候，只需要把第一个元素pop出来就好了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># This is the interface that allows for creating nested lists.</span>
<span class="c1"># You should not implement it, or speculate about its implementation</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1">#class NestedInteger(object):</span>
<span class="c1">#    def isInteger(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        @return True if this NestedInteger holds a single integer, rather than a nested list.</span>
<span class="c1">#        :rtype bool</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    def getInteger(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        @return the single integer that this NestedInteger holds, if it holds a single integer</span>
<span class="c1">#        Return None if this NestedInteger holds a nested list</span>
<span class="c1">#        :rtype int</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    def getList(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        @return the nested list that this NestedInteger holds, if it holds a nested list</span>
<span class="c1">#        Return None if this NestedInteger holds a single integer</span>
<span class="c1">#        :rtype List[NestedInteger]</span>
<span class="c1">#        &quot;&quot;&quot;</span>

<span class="c1"># class NestedIterator(object):</span>

<span class="c1">#     def __init__(self, nestedList):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Initialize your data structure here.</span>
<span class="c1">#         :type nestedList: List[NestedInteger]</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         self.buffer = sum((NestedIterator.flatten(v) for v in nestedList), [])</span>

<span class="c1">#     @staticmethod</span>
<span class="c1">#     def flatten(array: &quot;NestedIterator&quot;) -&gt; &quot;List&quot;:</span>
<span class="c1">#         if array.isInteger():</span>
<span class="c1">#             return [array.getInteger()]</span>
<span class="c1">#         else:</span>
<span class="c1">#             res = []</span>

<span class="c1">#             for v in array.getList():</span>
<span class="c1">#                 if v.isInteger():</span>
<span class="c1">#                     res.append(v.getInteger())</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     res.extend(NestedIterator.flatten(v))</span>

<span class="c1">#             return res</span>

<span class="c1">#     def next(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         :rtype: int</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         return self.buffer.pop(0)</span>

<span class="c1">#     def hasNext(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         :rtype: bool</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         return self.buffer != []</span>

<span class="c1"># Your NestedIterator object will be instantiated and called as such:</span>
<span class="c1"># i, v = NestedIterator(nestedList), []</span>
<span class="c1"># while i.hasNext(): v.append(i.next())</span>

<span class="c1"># 像上面的做法面试里面一定会被批判的，因为太浪费内存了</span>

<span class="kn">import</span> <span class="nn">collections</span>

<span class="k">class</span> <span class="nc">NestedIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nestedList</span><span class="p">:</span> <span class="p">[</span><span class="n">NestedInteger</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">nestedList</span><span class="p">)</span> <span class="c1"># 搞一个queue</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span><span class="o">.</span><span class="n">getInteger</span><span class="p">()</span> <span class="c1"># 只要把第一个元素pop出来就可以了</span>

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span> <span class="c1"># queue当然不能为空</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isInteger</span><span class="p">():</span> <span class="c1"># 如果发现第一个元素已经是integer了</span>
                <span class="k">return</span> <span class="bp">True</span> <span class="c1"># 那下一次next()就pop这个</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 如果发现第一个元素不是integer</span>
                <span class="n">toExpand</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span><span class="o">.</span><span class="n">getList</span><span class="p">())</span> <span class="c1"># 把第一个元素展开</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">toExpand</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="c1"># 展开之后放到最前面。到下一个迭代再来检测第一个元素到底是不是integer，如果还不是的话，继续展开，直到是integer为止</span>

        <span class="k">return</span> <span class="bp">False</span> <span class="c1"># queue为空说明没有下一个了</span>

<span class="c1"># Your NestedIterator object will be instantiated and called as such:</span>
<span class="c1"># i, v = NestedIterator(nestedList), []</span>
<span class="c1"># while i.hasNext(): v.append(i.next())</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">Amazon题库</a><ul>
<li><a class="reference internal" href="#id3">二叉树的最大深度</a></li>
<li><a class="reference internal" href="#id4">二叉树是否是另一棵二叉树的子树</a></li>
<li><a class="reference internal" href="#id5">一组一组地颠倒链表</a></li>
<li><a class="reference internal" href="#x-n">不使用内建函数实现 <span class="math notranslate nohighlight">\(x^n\)</span></a></li>
<li><a class="reference internal" href="#id6">垂直遍历二叉树</a></li>
<li><a class="reference internal" href="#sum">2 sum</a></li>
<li><a class="reference internal" href="#id7">竖式加法</a></li>
<li><a class="reference internal" href="#lru">实现LRU缓存</a></li>
<li><a class="reference internal" href="#substring">最长回文substring</a></li>
<li><a class="reference internal" href="#id8">岛屿的数量</a></li>
<li><a class="reference internal" href="#lfu">实现LFU缓存</a></li>
<li><a class="reference internal" href="#id11">关键通路</a></li>
<li><a class="reference internal" href="#id13">验证括号嵌套</a></li>
<li><a class="reference internal" href="#id14">合并两个排好序的链表</a></li>
<li><a class="reference internal" href="#id15">合并多个排好序的链表</a></li>
<li><a class="reference internal" href="#id16">排序两种日志字符串</a></li>
<li><a class="reference internal" href="#id17">链表深复制</a></li>
<li><a class="reference internal" href="#id19">整数的英文说法</a></li>
<li><a class="reference internal" href="#id20">序列化和反序列化二叉树</a></li>
<li><a class="reference internal" href="#id21">最少需要多少间会议室</a></li>
<li><a class="reference internal" href="#k">离原点最近的 <span class="math notranslate nohighlight">\(k\)</span> 个点</a></li>
<li><a class="reference internal" href="#id24">乱序字符分组</a></li>
<li><a class="reference internal" href="#o-1">设计插入、删除、随机选取都是 <span class="math notranslate nohighlight">\(O(1)\)</span> 的数据结构</a></li>
<li><a class="reference internal" href="#id25">二叉树中最大路径和</a></li>
<li><a class="reference internal" href="#id26">嵌套列表降维</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/posts/amazon-interview/index.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">blog  文档</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, aiifabbf.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2 创建。
    </div>
  </body>
</html>