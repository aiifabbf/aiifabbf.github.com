
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="&#25968;&#23383;&#20449;&#21495;&#22788;&#29702;">&#25968;&#23383;&#20449;&#21495;&#22788;&#29702;<a class="anchor-link" href="#&#25968;&#23383;&#20449;&#21495;&#22788;&#29702;">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>问题列表</p>
<ul>
<li><a href="#sec:prove-dtft-orthogonality">怎么推导出DTFT的系数$X(e^{j 2 \pi f n})$</a></li>
<li><a href="#sec:z-inverse-transform">怎么理解$z$反变换</a></li>
<li><a href="#sec:impulse-invariance">冲激响应不变法中的系数$T_s$从哪里来</a></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>\begin{align}</p>
<p>\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="&#31532;&#19968;&#31456;">&#31532;&#19968;&#31456;<a class="anchor-link" href="#&#31532;&#19968;&#31456;">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="&#31532;&#20108;&#31456;">&#31532;&#20108;&#31456;<a class="anchor-link" href="#&#31532;&#20108;&#31456;">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="&#31532;&#19977;&#31456;">&#31532;&#19977;&#31456;<a class="anchor-link" href="#&#31532;&#19977;&#31456;">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="DTFT">DTFT<a class="anchor-link" href="#DTFT">&#182;</a></h2><blockquote><p>所有的变换对都可以当做第一个例子里展现的那样、用坐标变换、换基底的思想来理解。</p>
<p>离散函数，比如$x[n]$可以粗略地理解成无穷可数维空间中的一个点或者向量。连续函数$x(t)$可以粗略地理解成一个无穷不可数维空间中的一个点或者向量。</p>
</blockquote>
<p>回想一个$n$维向量$\vec{x}$按一组正交单位基底$\{\vec{e}_n\}$展开
\begin{align}
    \vec{x} &amp;= X_1 \vec{e}_1 + X_2 \vec{e}_2 + \ldots + X_n \vec{e}_n \\
    &amp;= \sum_{k = 1}^n X_k \vec{e}_k
\end{align}
其中$X_k$就是$\vec{x}$在基底$\vec{e}_k$上的投影。</p>
<blockquote><p>正交的意思是$\forall k_1 \neq k_2: \langle \vec{e}_{k_1}, \vec{e}_{k_2} \rangle = 0$且$\forall k: \langle \vec{e}_{k}, \vec{e}_{k} \rangle \neq 0$。</p>
</blockquote>
<p>投影$X_k$是这样计算的
\begin{align}
    X_k &amp;= \langle \vec{e}_k, \vec{x} \rangle \\
    &amp;= \vec{e}_k^* \cdot \vec{x}
\end{align}</p>
<blockquote><p>因为$n$维空间线性无关基底的数量是$n$，所以需要$n$个基底来表示$\vec{x}$。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="CTFS">CTFS<a name="sec:ctfs" /><a class="anchor-link" href="#CTFS">&#182;</a></h3><p>回想连续周期信号$x(t)$，周期是$f_0^{-1}$，按正交函数系$\{e^{j 2 \pi n f_0 t} | n \in Z\}$展开（<a href="#sec:prove-ctfs-orthogonality">证明正交</a>）
\begin{align}
    x(t) &amp;= X_0 e^{j 2 \pi 0 f_0 t} &amp;&amp; + X_1 e^{j 2 \pi 1 f_0 t} &amp;&amp; + X_2 e^{j 2 \pi 2 f_0 t} + \ldots \\
    &amp; &amp;&amp; + X_{-1} e^{j 2 \pi (-1) f_0 t} &amp;&amp; + X_{-2} e^{j 2 \pi (-2) f_0 t} + \ldots \\
    &amp;= \sum_{k=-\infty}^{\infty} X_k e^{j 2 \pi k f_0 t}
\end{align}
其中$X_k$就是$x(t)$在基底$e^{j 2 \pi k f_0 t}$上的投影。</p>
<p>投影$X_k$是这样计算的
\begin{align}
    X_k &amp;= f_0 \langle e^{j 2 \pi k f_0 t}, x(t) \rangle \\
    &amp;= f_0 \int_{C}^{C + {1 \over f_0}} \left(e^{j 2 \pi k f_0 t}\right)^* x(t) \,dt \\
    &amp;= f_0 \int_{C}^{C + {1 \over f_0}} e^{- j 2 \pi k f_0 t} x(t) \,dt
\end{align}</p>
<blockquote><p>这里我不理解为什么积分的范围只要一个周期。</p>
<p>但是用了Fourier's trick就完全避免了系数问题。</p>
<p>这里有一个$f_0$系数的原因是，正交函数系$\{e^{j 2 \pi n f_0 t} | n \in Z\}$不是归一的。意思是基底的长度不是单位长度（<a href="#sec:ctfs-basevector-length">那么基底的长度是多少？</a>），同一个基底内积的结果不是1，而是${1 \over f_0}$。见<a href="#sec:prove-ctfs-orthogonality">证明正交</a>。</p>
</blockquote>
<p>投影$X_k$好像还可以是这样计算的。这个称为<a href="#sec:fourier&#39;s-trick">Fourier's trick</a>
\begin{align}
    \color{red}{\int_{C}^{C + {1 \over f_0}}} x(t) \color{red}{e^{-j 2 \pi k f_0 t} \,dt} = \color{red}{\int_{C}^{C + {1 \over f_0}}} \sum_{n=-\infty}^{\infty} X_n e^{j 2 \pi n f_0 t} \color{red}{e^{-j 2 \pi k f_0 t} \,dt}
\end{align}
简单来说就是在综合公式的两边同时内积一个$e^{j 2 \pi k f_0 t}$，即同时乘以一个$e^{- j 2 \pi k f_0 t}$再积分。上面的式子交换求和和积分次序，得到
\begin{align}
    \int_{C}^{C + {1 \over f_0}} x(t) e^{-j 2 \pi k f_0 t} \,dt =  \sum_{n=-\infty}^{\infty} X_n \underbrace{\int_{C}^{C + {1 \over f_0}} e^{j 2 \pi n f_0 t} e^{-j 2 \pi k f_0 t} \,dt}_{\begin{cases}
        0, &amp;\qquad n \neq k \\
        {1 \over f_0}, &amp;\qquad n = k
    \end{cases}}
\end{align}
这里用到了<a href="#sec:prove-ctfs-orthogonality">证明正交</a>的结论。所以右边的求和只剩下了$n = k$时的一项
\begin{align}
    \int_{C}^{C + {1 \over f_0}} x(t) e^{-j 2 \pi k f_0 t} \,dt = {1 \over f_0} X_k
\end{align}</p>
<blockquote><p>关于Fourier's trick，这个技巧是我在Griffiths的<em>Introduction to Quantum Mechanics</em>这本书里看到的。也有人在<a href="https://math.stackexchange.com/questions/705096/why-is-this-allowed-fouriers-trick-finding-the-coefficients-in-a-fourier-s">质疑这个做法</a>。具体为什么可能要学泛函分析。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="CTFT">CTFT<a class="anchor-link" href="#CTFT">&#182;</a></h3><p>回想连续信号$x(t)$按正交函数系$\{e^{j 2 \pi f t} | f \in R\}$展开（<a href="#sec:prove-ctft-orthogonality">证明正交</a>）
\begin{align}
    x(t) = \int_{-\infty}^{\infty} X(j 2 \pi f) e^{j 2 \pi f t} \,df
\end{align}
其中$X(j 2 \pi f)$就是$x(t)$在基底$e^{j 2 \pi f t}$上的投影。</p>
<p>投影$X(j 2 \pi f)$是这样计算的
\begin{align}
    X(j 2 \pi f) &amp;= \langle e^{j 2 \pi f t}, x(t) \rangle \\
    &amp;= \int_{-\infty}^{\infty} \left(e^{j 2 \pi f t}\right)^* x(t) \,dt \\
    &amp;= \int_{-\infty}^{\infty} e^{- j 2 \pi f t} x(t) \,dt
\end{align}</p>
<blockquote><p>你可能会疑惑为什么不写成$X(f)$而非要写成$X(j 2 \pi f)$。其实$X(f)$也是可以的，但是在拉普拉斯变换中变换域函数写成$X(s)$。为了体现和拉普拉斯变换的关系，即令$s = j 2 \pi f$，拉普拉斯变换域函数$X(s)$退化成傅里叶变换域函数$X(f)$，这里就写作$X(j 2 \pi f)$。</p>
</blockquote>
<p>用Fourier's trick算投影
\begin{align}
    \color{red}{\int_{-\infty}^{+\infty}} x(t) \color{red}{e^{- j 2 \pi f' t} \,dt} = \color{red}{\int_{-\infty}^{+\infty}} \int_{-\infty}^{\infty} X(j 2 \pi f) e^{j 2 \pi f t} \,df \color{red}{e^{- j 2 \pi f' t} \,dt}
\end{align}
交换积分次序
\begin{align}
    \int_{-\infty}^{+\infty} x(t) e^{- j 2 \pi f' t} \,dt &amp;= \int_{-\infty}^{+\infty} X(j 2 \pi f) \underbrace{\int_{-\infty}^{\infty} e^{j 2 \pi f t} e^{- j 2 \pi f' t} \,dt}_{\delta(f - f')}\,df \\ 
    &amp;= X(j 2 \pi f')
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="DTFT">DTFT<a name="sec:dtft" /><a class="anchor-link" href="#DTFT">&#182;</a></h3><p>把$x[n]$按一个正交函数系$\left\{e^{j 2 \pi f n} \mid f \in [- {1 \over 2}, {1 \over 2}]\right\}$展开（<a href="#sec:prove-dtft-orthogonality">证明正交</a>）
\begin{align}
    x[n] = \int_{- {1 \over 2}}^{1 \over 2} X(e^{j 2 \pi f}) e^{j 2 \pi f n} \,df
\end{align}</p>
<p>在任意一个基底$e^{j 2 \pi f n}$上的投影$X(e^{j 2 \pi f})$是这样计算的
\begin{align}
    X(e^{j 2 \pi f}) = \sum_{k = -\infty}^{+\infty} e^{- j 2 \pi f k} x[k]
\end{align}</p>
<blockquote><p>这里细说的话，$n$是没有量纲的，所以变换过去的$f$也没有量纲。</p>
<p>从信息的角度讲，$x(n T_s)$变成$x[n]$的过程，丢弃了采样间隔这个信息，所以频域自然也不可能凭空出现这个信息。</p>
<p>所有的变换都需要满足原变量和变换域变量的量纲互为倒数的关系（<a href="">为什么？</a>）</p>
</blockquote>
<p>发现$X(e^{j 2 \pi f n})$是周期函数，周期是$1$。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#35777;&#26126;$\{e^{j-2-\pi-f-t}-|-f-\in-R\}$&#26159;&#27491;&#20132;&#24402;&#19968;&#20989;&#25968;&#31995;">&#35777;&#26126;$\{e^{j 2 \pi f t} | f \in R\}$&#26159;&#27491;&#20132;&#24402;&#19968;&#20989;&#25968;&#31995;<a name="sec:prove-ctft-orthogonality" /><a class="anchor-link" href="#&#35777;&#26126;$\{e^{j-2-\pi-f-t}-|-f-\in-R\}$&#26159;&#27491;&#20132;&#24402;&#19968;&#20989;&#25968;&#31995;">&#182;</a></h3><p>\begin{align}
    \left\langle e^{j 2 \pi f_1 t}, e^{j 2 \pi f_2 t} \right\rangle &amp;= \int_{-\infty}^{+\infty} \left(e^{j 2 \pi f_1 t}\right)^* e^{j 2 \pi f_2 t} \,dt \\
    &amp;= \int_{-\infty}^{+\infty} e^{- j 2 \pi f_1 t} e^{j 2 \pi f_2 t} \,dt \\
    &amp;= \int_{-\infty}^{+\infty} e^{j 2 \pi (f_2 - f_1) t} \,dt \\
    &amp;= \int_{-\infty}^{+\infty} e^{- j 2 \pi (f_1 - f_2) t} \,dt \\
    &amp;= \delta(f_1 - f_2)
\end{align}
最后一步用到了
\begin{align}
    1 \mathop{\longleftrightarrow}^{\cal F} \delta(f)
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#35777;&#26126;$\{e^{j-2-\pi-n-f_0-t}-|-n-\in-Z\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#35777;&#26126;$\{e^{j 2 \pi n f_0 t} | n \in Z\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;<a name="sec:prove-ctfs-orthogonality" /><a class="anchor-link" href="#&#35777;&#26126;$\{e^{j-2-\pi-n-f_0-t}-|-n-\in-Z\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#182;</a></h3><p>\begin{align}
    \langle e^{j 2 \pi n_1 f_0 t}, e^{j 2 \pi n_2 f_0 t} \rangle &amp;= \int_{C }^{C + {1 \over f_0}} \left(e^{j 2 \pi n_1 f_0 t}\right)^* e^{j 2 \pi n_2 f_0 t} \,dt \\
    &amp;= \int_{C }^{C + {1 \over f_0}} e^{- j 2 \pi n_1 f_0 t} e^{j 2 \pi n_2 f_0 t} \,dt \\
    &amp;= \int_{C }^{C + {1 \over f_0}} e^{j 2 \pi (n_2 - n_1) f_0 t} \,dt \\
    &amp;= \left.{1 \over j 2 \pi (n_2 - n_1) f_0} e^{j 2 \pi (n_2 - n_1) f_0 t} \right|^{1 \over f_0}_{0} \\
    &amp;= {e^{j 2 \pi (n_2 - n_1)} - 1 \over j 2 \pi (n_2 - n_1) f_0} \\
    &amp;= \begin{cases}
        0, &amp;\qquad n_1 \neq n_2 \\
        \textrm{undefined}, &amp;\qquad n_1 = n_2
    \end{cases}
\end{align}
最后一步用到了$e^{j 2 \pi n} = \cos(2 \pi n) + j \sin(2 \pi n) = 1$。</p>
<p>这里当$n_1 = n_2$的时候出现了一个奇点，但是这是一个可去奇点
\begin{align}
    \lim_{n \to 0} {e^{j 2 \pi n} - 1 \over j 2 \pi n f_0} &amp;= \lim_{n \to 0} {j 2 \pi \cdot e^{j 2 \pi n} \over j 2 \pi f_0} = {1 \over f_0}
\end{align}
所以"不妨"就认为
\begin{align}
    \langle e^{j 2 \pi n_1 f_0 t}, e^{j 2 \pi n_2 f_0 t} \rangle = \begin{cases}
        0, &amp;\qquad n_1 \neq n_2 \\
        {1 \over f_0}, &amp;\qquad n_1 = n_2
    \end{cases}
\end{align}</p>
<blockquote><p>我不知道为什么可以"不妨"。</p>
</blockquote>
<p>所以函数系$\{e^{j 2 \pi n f_0 t} | n \in Z\}$正交，但是不归一，因为同一个基底的自内积不为</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#35777;&#26126;$\{e^{j-2-\pi-f-n}-|-f-\in-[--{1-\over-2},-{1-\over-2}]\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#35777;&#26126;$\{e^{j 2 \pi f n} | f \in [- {1 \over 2}, {1 \over 2}]\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;<a name="sec:prove-dtft-orthogonality" /><a class="anchor-link" href="#&#35777;&#26126;$\{e^{j-2-\pi-f-n}-|-f-\in-[--{1-\over-2},-{1-\over-2}]\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#182;</a></h3><p>\begin{align}
    \langle e^{j 2 \pi f_1 n}, e^{j 2 \pi f_2 n} \rangle &amp;= \sum_{n = -\infty}^{+\infty} (e^{j 2 \pi f_1 n})^* e^{j 2 \pi f_2 n} \\
    &amp;= \sum_{n = -\infty}^{+\infty} e^{- j 2 \pi f_1 n} e^{j 2 \pi f_2 n} \\
    &amp;= \sum_{n = -\infty}^{+\infty} e^{j 2 \pi (f_2 - f_1) n} \\
    &amp;= 
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#37319;&#26679;">&#37319;&#26679;<a name="sec:sampling" /><a class="anchor-link" href="#&#37319;&#26679;">&#182;</a></h3><p>有两种采样的方法。第一种是用一个周期为$T_s$的单位冲激信号序列
\begin{align}
    \operatorname{III}(t) = \sum_{n = -\infty}^{+\infty} \delta(t - n T_s)
\end{align}
乘原信号，得到<strong>理想采样输出</strong>信号
\begin{align}
    \hat{x}(t) &amp;= \operatorname{III}(t) x(t) \\
    &amp;= \sum_{n = -\infty}^{+\infty} x(t) \delta(t - n T_s) \\
    &amp;= \sum_{n = -\infty}^{+\infty} x(n T_s) \delta(t - n T_s)
\end{align}</p>
<blockquote><p>顺便提一句
\begin{align}
    \operatorname{III}(t) \mathop{\longleftrightarrow}^{\cal F} \color{red}{1 \over T_s} \sum_{n = -\infty}^{+\infty} \delta\left(f - {n \over T_s}\right)
\end{align}
千万别忘记前面的系数。</p>
</blockquote>
<p>第二种是直接定义一个离散信号$x[n]$，使
\begin{align}
    x[n] = x(n T_s)
\end{align}
称为<strong>实际采样输出</strong>信号。</p>
<p>这两种方法的频谱有关联。先看理想采样输出信号的频谱
\begin{align}
    \hat{X}(j 2 \pi f) &amp;= \int_{-\infty}^{+\infty} \hat{x}(t) e^{- j 2 \pi f t} \,dt \\
    &amp;= \int_{-\infty}^{+\infty} \left[\sum_{n = -\infty}^{+\infty} x(t) \delta(t - n T_s)\right] e^{- j 2 \pi f t} \,dt \\
    &amp;= \int_{-\infty}^{+\infty} \left[\sum_{n = -\infty}^{+\infty} x(t) \delta(t - n T_s) e^{- j 2 \pi f t}\right] \,dt \\
    &amp;= \int_{-\infty}^{+\infty} \left[\sum_{n = -\infty}^{+\infty} x(n T_s) \delta(t - n T_s) e^{- j 2 \pi f n T_s}\right] \,dt \\
    &amp;= \sum_{n = -\infty}^{+\infty} \left[\int_{-\infty}^{+\infty}  x(n T_s) \delta(t - n T_s) e^{- j 2 \pi f n T_s} \,dt\right] \\
    &amp;= \sum_{n = -\infty}^{+\infty} x(n T_s) e^{- j 2 \pi f n T_s} \int_{-\infty}^{+\infty} \delta(t - n T_s) \,dt \\
    &amp;= \sum_{n = -\infty}^{+\infty} x(n T_s) e^{- j 2 \pi f n T_s} \\
\end{align}</p>
<p>再来看离散信号$x[n]$的频谱
\begin{align}
    X(e^{j 2 \pi f}) &amp;= \sum_{n = -\infty}^{+\infty} x[n] e^{- j 2 \pi f n}
\end{align}
回想$x[n] = x(n T_s)$，再把两个放在一起对比
\begin{align}
    \hat{X}(j 2 \pi f) &amp;= \sum_{n = -\infty}^{+\infty} x(n T_s) e^{- j 2 \pi \color{red}{f n T_s}} \\
    X(e^{j 2 \pi f}) &amp;= \sum_{n = -\infty}^{+\infty} x(n T_s) e^{- j 2 \pi \color{red}{f n}}
\end{align}
很明显，两个频谱就是横向伸缩的关系，也就是$\hat{X}\left(j 2 \pi {f \over T_s}\right) = X(e^{j 2 \pi f})$或者$\hat{X}(j 2 \pi f) = X(e^{j 2 \pi f T_s})$</p>
<blockquote><p>这里再次表明了离散时间傅里叶变换DTFT中频域函数$X(e^{j 2 \pi f})$的变量$f$是无量纲的。而连续时间傅里叶变换CTFT中频域函数$X(j 2 \pi f)$的变量$f$是有量纲的，量纲是$\rm s^{-1}$。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="$z$&#21464;&#25442;">$z$&#21464;&#25442;<a class="anchor-link" href="#$z$&#21464;&#25442;">&#182;</a></h2><p>把$x[n]$按一个正交函数系$\{z^n | z \in C\}$展开（<a href="#sec:prove-z-orthogonality">证明正交</a>）
\begin{align}
    x[n] = {1 \over j 2 \pi} \oint_C X(z) z^{n-1} \,dz
\end{align}
曲线$C$是复平面上的一条简单曲线，必须全部在收敛域ROC中（<a href="#sec:z-transform-roc-explained">收敛域是什么</a>），且需要包围零点$z = 0$。</p>
<blockquote><p>目前我还无法理解这个式子。</p>
</blockquote>
<p>$x[n]$在任意一个基底$z^n$上的投影是这样计算的
\begin{align}
    X(z) = \sum_{n = -\infty}^{+\infty} z^{-n} x[n]
\end{align}</p>
<blockquote><p>可以发现$z$变换和洛朗级数Laurent Series非常相似。式子$X(z) = \sum_{n = -\infty}^{+\infty} z^{-n} x[n]$完全可以理解成一个函数$X(z)$在$0$处作洛朗级数展开。</p>
<p>$0$处洛朗级数的定义是$X(z) = \sum_{n = -\infty}^{+\infty} x_n z^n$。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#25910;&#25947;&#22495;ROC">&#25910;&#25947;&#22495;ROC<a name="sec:z-transform-roc-explained" /><a class="anchor-link" href="#&#25910;&#25947;&#22495;ROC">&#182;</a></h3><p>既然是洛朗级数，那么展开一定是有收敛域的。必须要保证式子$X(z) = \sum_{n = -\infty}^{+\infty} z^{-n} x[n]$的右半边是有意义的。</p>
<blockquote><p>比如考虑
\begin{align}
    x[n] = \begin{cases}
        1, &amp;\qquad n = 0 \\
        0, &amp;\qquad {\rm otherwise}
    \end{cases}
\end{align}
那么
\begin{align}
    \sum_{n = +\infty}^{+\infty} z^{-n} x[n] = z^{-0} = 1
\end{align}
是一个常数，即$X(z) = 1$，已经与$z$无关了，当然收敛域是整个复平面$C$。</p>
</blockquote>
<p>收敛的充分必要条件是
\begin{align}
    \sum_{n = -\infty}^{+\infty} \left|z^{-n} x[n]\right| = C
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#38463;&#36125;&#23572;&#23450;&#29702;">&#38463;&#36125;&#23572;&#23450;&#29702;<a class="anchor-link" href="#&#38463;&#36125;&#23572;&#23450;&#29702;">&#182;</a></h4><p>对于级数
\begin{align}
    \sum_{n = 0}^{+\infty} x[n] z^n
\end{align}
如果级数在$z_0$处收敛，那么就能保证级数在$\left\{z \mid |z| &lt; |z_0|\right\}$的范围里绝对收敛。把$|z_0|$记作$R$，称为最大收敛半径。</p>
<blockquote><p>意思是超过这个半径的都不能保证收敛了。所以这个是最大的收敛半径。</p>
</blockquote>
<p>所以对于级数
\begin{align}
    \sum_{n = 0}^{+\infty} x[n] {1 \over z^n}
\end{align}
如果级数在$z_0$处收敛，那么就保证级数在$\left\{z \mid |z| &gt; |z_0|\right\}$的范围里为绝对收敛。把$|z_0|$记作$R$，称为最小收敛半径。</p>
<blockquote><p>意思是低于这个半径的都不保证收敛了。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#26377;&#38480;&#38271;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;">&#26377;&#38480;&#38271;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;<a class="anchor-link" href="#&#26377;&#38480;&#38271;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;">&#182;</a></h4><p>有限长序列的定义是
\begin{align}
    \exists n_1, n_2 \in Z, \forall n \in (-\infty, n_1) \cup (n_2, +\infty): \qquad x[n] = 0
\end{align}
意思是存在一个区间，这个区间之外的$n$都满足$x[n] = 0$。</p>
<p>这样有限长序列的$z$变换就是
\begin{align}
    X(z) = \sum_{n = n_1}^{n_2} z^{-n} x[n] = \sum_{n = n_1}^{n_2} {1 \over z^n} x[n]
\end{align}</p>
<p>需要讨论$X(z)$的展开式是否包含$z$的正阶数项或负阶数项，才能最终确定$0$和$\infty$是否在收敛域中。这里先假设$n_1 &lt; 0, n_2 &gt; 0$
\begin{align}
    X(z) &amp;= \sum_{n = n_1}^{n_2} z^{-n} x[n] \\
    &amp;= \underbrace{{1 \over z^{n_1}} x[n_1] + {1 \over z^{n_1 + 1}} x[n_1 + 1] + \ldots}_{z的正阶数项} + {1 \over z^0} x[0] + \underbrace{\ldots + {1 \over z^{n_2 - 1}} x[n_2 - 1] + {1 \over z^{n_2}} x[n_2]}_{z的负阶数项}
\end{align}</p>
<p>对于$z$的负阶数项，$\infty$不是极点，因为在$\infty$处是有限值$0$；$0$是极点，因为在$0$处是无限值$\infty$。所以对每一个$z$的负阶数项而言，收敛域是$C \backslash \{0\}$。</p>
<p>对于$z$的正阶数项，$\infty$是极点，因为在$\infty$处是无限值$\infty$；$0$不是极点，因为在$0$处是有限值$0$。所以对每一个$z$的正阶数项而言，收敛域是$C \backslash \{\infty\}$</p>
<p>对于$z$的0次阶数项，$\infty$和$0$都不是极点。所以收敛域是整个复平面$C$。</p>
<p>所以如果$n_1 \geq 0$，即<strong>如果不包含$z$的正数阶项</strong>，那么收敛域是$C \backslash \{0\}$，<strong>可以包括无穷远点$\infty$。</strong></p>
<p>如果$n_2 \leq 0$，即<strong>如果不包含$z$的负数阶项</strong>，那么收敛域是$C \backslash \{\infty\}$，<strong>可以包含原点$0$。</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#21491;&#36793;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;">&#21491;&#36793;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;<a class="anchor-link" href="#&#21491;&#36793;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;">&#182;</a></h4><p>右边序列的定义是
\begin{align}
    \exists n_1 \in Z, \forall n &lt; 0: \qquad x[n] = 0
\end{align}
意思是存在一个左边界，使得所有左边界以外的$n$都满足$x[n] = 0$。</p>
<p>如果$n_1 &lt; 0$，那么展开式包含$z$的正阶数项，所以收敛域不包括无穷远点$\infty$。收敛域是$\{z | R &lt; |z|\} \backslash \infty$。</p>
<p>如果$n_1 \geq 0$，那么称为<strong>因果序列</strong>，那么展开式不包含$z$的正阶数项，所以收敛域能包括无穷远点$\infty$。收敛域是$\{z | R &lt; |z|\}$。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#24038;&#36793;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;">&#24038;&#36793;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;<a class="anchor-link" href="#&#24038;&#36793;&#24207;&#21015;&#30340;&#25910;&#25947;&#22495;">&#182;</a></h4><p>左边序列的定义是
\begin{align}
    \exists n_2 \in Z, \forall n &gt; 0: \qquad x[n] = 0
\end{align}
意思是存在一个右边界，使得所有右边界以外的$n$都满足$x[n] = 0$。</p>
<p>如果$n_2 &gt; 0$，那么展开式会包含$z$的负阶数项，所以收敛域不包括原点$0$。收敛域是$\{z | 0 &lt; |z| &lt; R\}$。</p>
<p>如果$n_2 \leq 0$，那么展开式不包括$z$的负阶数项，所以收敛域能包括原点$0$。收敛域是$\{z | 0 \leq |z| &lt; R\}$。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#21452;&#36793;&#24207;&#21015;">&#21452;&#36793;&#24207;&#21015;<a class="anchor-link" href="#&#21452;&#36793;&#24207;&#21015;">&#182;</a></h4><p>双边序列的定义是
\begin{align}
    \forall n_0 \in Z^+, \exists n \in \left\{n \middle| |n| &gt; n_0\right\}: \qquad x[n] \neq 0
\end{align}
意思是找不到这样一个区间，使得区间外的所有$n$都满足$x[n] = 0$。</p>
<blockquote><p>定义的意思是，对于任何一个正整数，都存在另一个绝对值大于它的整数，使得$x[n]$不等于0。意思就是对任何拟划定的区间，都能找到一个区间外的整数$n$，使得$x[n]$不等于0。</p>
</blockquote>
<p>可以看做一个左边序列和一个右边序列拼起来。</p>
<p>如果左边序列的最大收敛半径是$R_+$，右边序列的最小收敛半径是$R_-$，那么收敛域是$\{z | R_- &lt; |z| &lt; R_+\}$。</p>
<blockquote><p>收敛域如果存在的话，是一个圆环。当然也有可能收敛域是空集，如果$R_- \geq R_+$的话。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#21453;&#21464;&#25442;">&#21453;&#21464;&#25442;<a name="sec:z-inverse-transform" /><a class="anchor-link" href="#&#21453;&#21464;&#25442;">&#182;</a></h3><p>反变换的定义是
\begin{align}
    x[n] = {1 \over j 2 \pi} \oint_C X(z) z^{n-1} \,dz
\end{align}
曲线$C$是复平面上的一条简单曲线，必须全部在收敛域ROC中，且需要包围原点$z = 0$。</p>
<p>这个定义衍生出了两种计算反变换的方法</p>
<ul>
<li>留数法</li>
<li>部分分式法</li>
</ul>
<blockquote><p>留数法是严格按照定义来算，适用范围最广，一切形式的$X(z)$函数都可以适用。部分分式法其实可以看做对有理函数的加速，只适用于$X(z)$是有理函数的情况。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#30041;&#25968;&#27861;">&#30041;&#25968;&#27861;<a class="anchor-link" href="#&#30041;&#25968;&#27861;">&#182;</a></h4><p>$f(z)$的有一个极点$p_0$，那么$f(z)$在$p_0$处的留数的是
\begin{align}
    \operatorname{Res} (f(z), p_0) = {1 \over j 2 \pi} \oint_\gamma f(z) \,dz
\end{align}
$\gamma$是仅包含$z_0$的简单曲线。</p>
<p>如果$\gamma$包含了$f(z)$的$n$个极点$\{p_1, p_2, \ldots, p_n\}$，那么
\begin{align}
    {1 \over j 2 \pi} \oint_\gamma f(z) \,dz = \sum_{k = 1}^{n} \operatorname{Res} (f(z), p_k)
\end{align}</p>
<p>由柯西积分定理，$\gamma$外如果有$n$个极点$\{p_1', p_2', \ldots, p_n'\}$，那么
\begin{align}
    {1 \over j 2 \pi} \oint_{\gamma^-} f(z) \,dz = \sum_{k = 1}^{n} \operatorname{Res} (f(z), p_k')
\end{align}
又因为
\begin{align}
    {1 \over j 2 \pi} \oint_{\gamma^-} f(z) \,dz = - {1 \over j 2 \pi} \oint_\gamma f(z) \,dz
\end{align}
所以
\begin{align}
    {1 \over j 2 \pi} \oint_\gamma f(z) \,dz = - \sum_{k = 1}^{n} \operatorname{Res} (f(z), p_k')
\end{align}</p>
<blockquote><p>也就是说，算围栏积分，既可以用曲线内部的极点留数和也可以用曲线外面的极点留数和，怎么方便怎么来。假如曲线内部包含很多个极点，而曲线外面只有1个极点，那么用曲线外极点留数来算显然更方便。</p>
<p>这里说</p>
<blockquote><p><strong>$\gamma$外</strong>如果有$n$个极点$\{p_1', p_2', \ldots, p_n'\}$</p>
</blockquote>
<p>其实等价于说</p>
<blockquote><p><strong>$\gamma^-$内</strong>有$n$个极点$\{p_1', p_2', \ldots, p_n'\}$</p>
</blockquote>
</blockquote>
<p>观察反变换式子，发现等式右边计算的是$C$内函数$X(z) z^{n-1}$的留数和
\begin{align}
    {1 \over j 2 \pi} \oint_C X(z) z^{n-1} \,dz = \sum_{i = 1}^{k} \operatorname{Res} (X(z) z^{n-1}, p_i)
\end{align}
$p_i$指的是$C$内，函数$X(z) z^{n-1}$的极点。</p>
<blockquote><p>一定要记得$p_i$是函数$X(z) z^{n-1}$的极点，而不是函数$X(z)$的极点。</p>
</blockquote>
<p>或者
\begin{align}
    {1 \over j 2 \pi} \oint_C X(z) z^{n-1} \,dz = - \sum_{i = 1}^{k} \operatorname{Res} (X(z) z^{n-1}, p_i')
\end{align}
$p_i'$指的是$C$外（$C^-$内），函数$X(z) z^{n-1}$的极点。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#37096;&#20998;&#20998;&#24335;&#27861;">&#37096;&#20998;&#20998;&#24335;&#27861;<a class="anchor-link" href="#&#37096;&#20998;&#20998;&#24335;&#27861;">&#182;</a></h4><p>如果$X(z)$是一个有理函数，那么一定可以拆解成这种形式
\begin{align}
    X(z) &amp;= \\
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#35777;&#26126;$\{z^n-|-z-\in-Z\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#35777;&#26126;$\{z^n | z \in Z\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;<a name="sec:prove-z-orthogonality" /><a class="anchor-link" href="#&#35777;&#26126;$\{z^n-|-z-\in-Z\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#182;</a></h3><p>\begin{align}
    \langle z_1^n, z_2^n \rangle &amp;= \sum_{n = -\infty}^{+\infty} \left(z_1^n\right)^* z_2^n \\
    &amp;= \sum_{n = -\infty}^{+\infty} \left(z_1^*\right)^n z_2^n \\
    &amp;= 
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="DFT">DFT<a class="anchor-link" href="#DFT">&#182;</a></h2><blockquote><p>时域函数$f$和变换域函数$F$之间有某种对偶性</p>
<ul>
<li>$f$离散，$F$周期</li>
<li>$f$连续，$F$非周期</li>
<li>$f$周期，$F$离散</li>
<li>$f$非周期，$F$连续</li>
</ul>
<p>例如FS中$f$是周期连续函数，则$F$是离散非周期函数；FT中$f$是非周期连续函数，则$F$是连续非周期函数；DTFT中$f$是非周期离散函数，则$F$是连续周期函数。都无一例外符合这个对偶性。</p>
<p>DFT产生的一个重要动机是希望时域和变换域都是离散的。因此时域离散对应了频域周期，频域离散对应了时域周期。所以猜想DFT应该具有</p>
<ul>
<li>$f$离散、周期</li>
<li>$F$周期、离散</li>
</ul>
<p>有2种途径可以从上面我们已有的变换推导到DFT</p>
<ol>
<li>CTFS</li>
<li>DTFT</li>
</ol>
<p>在CTFS中，$f$是周期的但不离散，所以把$f$变成离散的就可以了。</p>
<p>在DTFT中，$f$是离散的但不周期，所以把$f$变成周期的就可以了。</p>
</blockquote>
<p>定义
\begin{align}
    X[k] = \sum_{n = 0}^{N - 1} x[n] e^{- j 2 \pi {k \over N} n}
\end{align}</p>
<p>用Fourier's trick解出$x[n]$
\begin{align}
    \color{red}{\sum_{k = 0}^{N - 1}} X[k] \color{red}{e^{j 2 \pi {n' \over N} k}} = \color{red}{\sum_{k = 0}^{N - 1}} \sum_{n = 0}^{N - 1} x[n] e^{- j 2 \pi {k \over N} n} \color{red}{e^{j 2 \pi {n' \over N} k}}
\end{align}
交换右边求和次序
\begin{align}
    \sum_{k = 0}^{N - 1} X[k] e^{j 2 \pi {k \over N} n'} &amp;= \sum_{n = 0}^{N - 1} x[n] \underbrace{\sum_{k = 0}^{N - 1} e^{- j 2 \pi {k \over N} n} e^{j 2 \pi {k \over N} n'}}_{= N \delta[n' - n]}
\end{align}
所以
\begin{align}
    \sum_{k = 0}^{N - 1} X[k] e^{j 2 \pi {k \over N} n'} &amp;= N x[n']
\end{align}</p>
<blockquote><p>这边的推导我想了很久很久。发现这里是第一次在分析公式上用Fourier's trick。和在综合公式上的用法有一点不同。</p>
</blockquote>
<p>DFT还可以写成矩阵形式
\begin{align}
    \vec{X} = \left(\begin{matrix}
        e^{- j 2 \pi {0 \over N} 0} &amp; e^{- j 2 \pi {0 \over N} 1} &amp; \cdots &amp; e^{- j 2 \pi {0 \over N} (N - 1)} \\
        e^{- j 2 \pi {1 \over N} 0} &amp; e^{- j 2 \pi {1 \over N} 1} &amp; \cdots &amp; e^{- j 2 \pi {1 \over N} (N - 1)} \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        e^{- j 2 \pi {N - 1 \over N} 0} &amp; e^{- j 2 \pi {N - 1 \over N} 1} &amp; \cdots &amp; e^{- j 2 \pi {N - 1 \over N} (N - 1)} \\
    \end{matrix}\right) \cdot \underbrace{\left(\begin{matrix}
        x[0] \\
        x[1] \\
        \vdots \\
        x[N - 1]
    \end{matrix}\right)}_{\vec{x}}
\end{align}
$\vec{X}$称为$X[k]$的主值序列。$X[k]$就是$\vec{X}$以$N$为周期的无限延拓。同理$\vec{x}$称为$x[n]$的主值序列。$x[n]$是$\vec{x}$以$N$为周期的无限延拓。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#20174;CTFS&#25512;&#21040;DFT">&#20174;CTFS&#25512;&#21040;DFT<a class="anchor-link" href="#&#20174;CTFS&#25512;&#21040;DFT">&#182;</a></h3><p>回想<a href="#sec:ctfs">CTFS</a>。$x(t)$是一个周期为$f_0^{-1}$的连续函数，按正交函数系$\{e^{j 2 \pi n f_0 t} | n \in Z\}$展开<sup>[证明正交](#sec:prove-ctfs-orthogonality)</sup>
\begin{align}
    x(t) &amp;= \sum_{k=-\infty}^{\infty} X_k e^{j 2 \pi k f_0 t}
\end{align}
其中$X_k$就是$x(t)$在基底$e^{j 2 \pi k f_0 t}$上的投影。</p>
<p>投影$X_k$是<a href="#sec:ctfs">这样计算的</a>
\begin{align}
    X_k &amp;= f_0 \int_{C}^{C + {1 \over f_0}} e^{- j 2 \pi k f_0 t} x(t) \,dt
\end{align}</p>
<p>现在，假设采样周期是$T_s$，这样在$x(t)$的一个周期$f_0^{-1}$里，会采样$(T_s f_0)^{-1}$个点，记为
\begin{align}
    N = {1 \over f_0 T_s}
\end{align}
这样可以知道$x(t)$在每个采样点上的值。令$t = n T_s$即可
\begin{align}
    x(\color{red}{n T_s}) &amp;= \sum_{k=-\infty}^{\infty} X_k e^{j 2 \pi k f_0 \color{red}{n T_s}}
\end{align}
再用$N = {1 \over f_0 T_s}$的关系
\begin{align}
    x(n T_s) &amp;= \sum_{k=-\infty}^{\infty} X_k e^{j 2 \pi k \color{red}{1 \over N T_s} n T_s}
\end{align}
再用$x[n] = x(n T_s)$，得到
\begin{align}
    x[n] = \sum_{k=-\infty}^{\infty} X_k e^{j 2 \pi {k \over N} n} \\
\end{align}</p>
<p>但是你会发现一个问题，似乎$X_k$是周期的，而且以$N$为周期，即
\begin{align}
    \forall k \in Z: \qquad X_k = X_{k + N}
\end{align}
这是因为基底是有限的$N$个，而不是无限可数个
\begin{align}
    \forall k \in Z: \qquad e^{j 2 \pi {k + N \over N} n} = e^{(j 2 \pi {k \over N} n + j 2 \pi n)} = e^{j 2 \pi {k \over N} n}
\end{align}</p>
<p>所以
\begin{align}
    x[n] = \sum_{k = 0}^{N - 1} X_k e^{j 2 \pi {k \over N} n} \\
\end{align}</p>
<blockquote><p>实际上不一定从$k = 0$求和到$N - 1$。任意一个完整周期都是可以的。</p>
</blockquote>
<p>把$X_k = f_0 \int_{C}^{C + {1 \over f_0}} e^{- j 2 \pi k f_0 t} x(t) \,dt$改造一下就可以变成DFT系数
\begin{align}
    X_k &amp;= f_0 \color{red}{\sum_{n = 0}^{N - 1}} e^{- j 2 \pi {k \over N} n} x(n T_s) \color{red}{T_s} \\
    &amp;= {1 \over N T_s} \sum_{n = 0}^{N - 1} e^{- j 2 \pi {k \over N} n} x[n] T_s \\
    &amp;= {1 \over N} \sum_{n = 0}^{N - 1} e^{- j 2 \pi {k \over N} n} x[n]
\end{align}</p>
<blockquote><p>这个"改造"的思路是，先把积分变成离散求和。本来积分上下限是$t$从$0$到${1 \over f_0}$，现在离散化之后，采样$N$个点，采样间隔是$T_s$，所以把$dt$变成$T_s$，把上下限从时间量纲（从0s积分到1s）变成序数量纲（从第一个点到最后一个点）。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#20174;DTFT&#25512;&#21040;DFT">&#20174;DTFT&#25512;&#21040;DFT<a class="anchor-link" href="#&#20174;DTFT&#25512;&#21040;DFT">&#182;</a></h3><p><strong>可惜的是，</strong>上面从CTFS推到DFT的做法是完全可行的，但是现实中没有人这么做。通常的DFT定义把系数$1 \over N$放到综合公式而不是分析公式。从这里能看出DFT是从DTFT推导的。</p>
<p>回忆DTFT的<a href="#sec:dtft">综合公式</a>
\begin{align}
    x[n] = \int_{- {1 \over 2}}^{1 \over 2} X(e^{j 2 \pi f}) e^{j 2 \pi f n} \,df
\end{align}
变成
\begin{align}
    x[n] &amp;= \color{red}{\sum_{k = 0}^{N - 1}} X(e^{j 2 \pi \color{red}{k \over N}}) e^{j 2 \pi \color{red}{k \over N} n} \color{red}{1 \over N} \\
    &amp;= {1 \over N} \sum_{k = 0}^{N - 1} X[k] e^{j 2 \pi {k \over N} n}
\end{align}
可以看到果然多了一个系数${1 \over N}$。</p>
<blockquote><p>"改造"思路和上面一模一样。$f$的范围是$[0, 1]$，又在这个范围里取$N$个点，采样间隔是${1 \over N}$，所以$df = {1 \over N}$，第$k$个采样点从$f$变成$k {1 \over T_s}$。</p>
<p>你可能会好奇凭什么时域采样$N$，频域也正好一样采样$N$个点？一个比较粗略的、不太能使人完全信服的理由是，为了保证$\forall n \in Z: x[n + N] = x[n]$，必须保证$f N \in Z$
\begin{align}
    \int_{- {1 \over 2}}^{1 \over 2} X(e^{j 2 \pi f n}) e^{j 2 \pi f n} \,df = \int_{- {1 \over 2}}^{1 \over 2} X(e^{j 2 \pi f n}) e^{j 2 \pi f n} \underbrace{e^{j 2 \pi f N}}_{必须是1} \,df
\end{align}</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#24615;&#36136;">&#24615;&#36136;<a class="anchor-link" href="#&#24615;&#36136;">&#182;</a></h3><p>以下均假设
\begin{align}
    x[n] \mathop{\longleftrightarrow}^{\rm DFT} X[k]
\end{align}</p>
<h4 id="&#26102;&#22495;&#24490;&#29615;&#20301;&#31227;">&#26102;&#22495;&#24490;&#29615;&#20301;&#31227;<a class="anchor-link" href="#&#26102;&#22495;&#24490;&#29615;&#20301;&#31227;">&#182;</a></h4><p>\begin{align}
    x[n - m] \mathop{\longleftrightarrow}^{\rm DFT} e^{- j 2 \pi {k \over N} m} X[k]
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#24490;&#29615;&#21367;&#31215;">&#24490;&#29615;&#21367;&#31215;<a class="anchor-link" href="#&#24490;&#29615;&#21367;&#31215;">&#182;</a></h3><p>一般的离散函数卷积的定义是
\begin{align}
    h[n] * x[n] = \sum_{k = -\infty}^{+\infty} h[k] x[n - k]
\end{align}
而循环卷积的定义是
\begin{align}
    \vec{h} \mathop{*}^{L} \vec{x} = \sum_{k = \color{red}{0}}^{\color{red}{L - 1}} \tilde{h}[k] \tilde{x}[n - k]
\end{align}
其中$\tilde{h}[n]$是$\vec{h}$的$L$周期的无限延拓，意思是如果$\vec{h}$里面的元素不足$L$个，就在后端补零直到长度变成$L$，再无限延拓。</p>
<p>也可以写成矩阵相乘形式
\begin{align}
    \vec{h} \mathop{*}^{L} \vec{x} = \left(\begin{matrix}
        \tilde{h}[0] &amp; \tilde{h}[-1] &amp; \ldots &amp; \tilde{h}[- (L - 1)] \\
        \tilde{h}[1] &amp; \tilde{h}[0] &amp; \ldots &amp; \tilde{h}[- (L - 2)] \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        \tilde{h}[L - 1] &amp; \tilde{h}[L - 2] &amp; \ldots &amp; \tilde{h}[0] \\
    \end{matrix}\right) \cdot \left(\begin{matrix}
        \tilde{x}[0] \\
        \tilde{x}[1] \\
        \vdots \\
        \tilde{x}[L - 1]
    \end{matrix}\right)
\end{align}
因为$\tilde{h}[n]$是周期$L$的离散函数，所以也可以写成
\begin{align}
    \vec{h} \mathop{*}^{L} \vec{x} = \left(\begin{matrix}
        \tilde{h}[0] &amp; \tilde{h}[L - 1] &amp; \ldots &amp; \tilde{h}[1] \\
        \tilde{h}[1] &amp; \tilde{h}[0] &amp; \ldots &amp; \tilde{h}[2] \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        \tilde{h}[L - 1] &amp; \tilde{h}[L - 2] &amp; \ldots &amp; \tilde{h}[0] \\
    \end{matrix}\right) \cdot \left(\begin{matrix}
        \tilde{x}[0] \\
        \tilde{x}[1] \\
        \vdots \\
        \tilde{x}[L - 1]
    \end{matrix}\right)
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#35777;&#26126;$\{e^{j-2-\pi-{k-\over-N}-n}-|-k-\in-[0,-1,-\ldots-N---1]\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#35777;&#26126;$\{e^{j 2 \pi {k \over N} n} | k \in [0, 1, \ldots N - 1]\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;<a class="anchor-link" href="#&#35777;&#26126;$\{e^{j-2-\pi-{k-\over-N}-n}-|-k-\in-[0,-1,-\ldots-N---1]\}$&#26159;&#27491;&#20132;&#20989;&#25968;&#31995;">&#182;</a></h3><p>\begin{align}
    \langle e^{j 2 \pi {k_1 \over N} n}, e^{j 2 \pi {k_2 \over N} n} \rangle &amp;= \sum_{n = 0}^{N - 1} e^{-j 2 \pi {k_1 \over N} n} e^{j 2 \pi {k_2 \over N} n} \\
    &amp;= \sum_{n = 0}^{N - 1} e^{j 2 \pi {k_2 - k_1 \over N} n} \\
    &amp;= N \underbrace{\delta[k_2 - k_1]}_{\begin{cases}
        0, &amp;\qquad k_2 \neq k_1 \\
        1, &amp;\qquad k_2 = k_1
    \end{cases}}
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="FFT">FFT<a class="anchor-link" href="#FFT">&#182;</a></h2><p>回想DFT的运算
\begin{align}
    X[k] &amp;= \sum_{n = 0}^{N - 1} x[n] e^{- j 2 \pi {k \over N} n} \\
    &amp;= \sum_{n = 0}^{N - 1} \Re(x[n]) \Re(\omega_N^{kn}) - \Im(x[n]) \Im(\omega_N^{kn}) + j \left[\Re(x[n]) \Im(\omega_N^{kn}) + \Im(x[n]) \Re(\omega_N^{kn})\right]
\end{align}</p>
<blockquote><p>2个复数相乘，相当于4次实数乘法、2次实数加法。2个复数相加，相当于2次实数加法。</p>
</blockquote>
<p>如果不计算计算$\omega_N^{kn}$需要的运算量，假设所有的$\omega_N^{kn}$一开始都算好了摆在那里，算出$\vec{X}$中的一项$X[k]$，就需要$4 N$次实数乘法、$2(2 N - 1)$次加法（减法算加法）。因为$\vec{X}$有$N$项，所以算出整个$\vec{X}$，需要$4 N^2$次乘法、$2 N(2 N - 1)$次加法。</p>
<p>所以普通的DFT算法时间复杂度是$O(n^2)$。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Coolkey-Tukey&#31639;&#27861;-aka.-DIT&#31639;&#27861;">Coolkey-Tukey&#31639;&#27861; aka. DIT&#31639;&#27861;<a class="anchor-link" href="#Coolkey-Tukey&#31639;&#27861;-aka.-DIT&#31639;&#27861;">&#182;</a></h3><p>回想DFT
\begin{align}
    X[k] = \sum_{n = 0}^{N - 1} x[n] e^{- j 2 \pi {k \over N} n} \\
\end{align}
可以分成两部分，$n$为偶数、$n$为奇数。
\begin{align}
    X[k] &amp;= \sum_{n = 0}^{\color{red}{N \over 2} - 1} x[\color{red}{2n}] e^{- j 2 \pi {k \over N} \color{red}{2n}} + \sum_{n = 0}^{\color{red}{N \over 2} - 1} x[\color{red}{2n + 1}] e^{- j 2 \pi {k \over N} \color{red}{(2n + 1)}} \\
    &amp;= \underbrace{\sum_{n = 0}^{{N \over 2} - 1} x[2n] e^{- j 2 \pi {k \over \color{red}{N / 2}} n}}_{x[2n]的DFT} + e^{- j 2 \pi {k \over N}} \underbrace{\sum_{n = 0}^{{N \over 2} - 1} x[2n + 1] e^{- j 2 \pi {k \over \color{red}{N / 2}} n}}_{x[2n + 1]的DFT}
\end{align}</p>
<p>这样，就把DFT问题分解成了2个DFT问题。只要分别求出$x[2n]$的DFT和$x[2n + 1]$的DFT就可以了。</p>
<blockquote><p>这样做的好处是，时间复杂度降低了非常多。如果仅仅假设作一次分解，那么原先要作$4 N^2$次实数加法运算、$2N(2N - 1)$次实数乘法，现在分解成两个长度为一半的序列，每个序列自己需要作$4 \left({N \over 2}\right)^2 = N^2$次实数加法运算、$N(N - 1)$次实数乘法，最后合并需要作1次复数乘法、1次复数加法，等价于4次实数乘法、4次实数加法，这样加起来，也就是$N^2 + 4$次实数加法、$N(N - 1) + 4$次实数乘法。</p>
</blockquote>
<p>$x[2n]$的DFT和$x[2n + 1]$的DFT里面的元素个数都是只有${N \over 2}$个，所以还可以利用$e^{- j 2 \pi {k \over N}}$的对称性，进一步化简成
\begin{align}
    X[k] &amp;= \sum_{n = 0}^{{N \over 2} - 1} x[2n] e^{- j 2 \pi {k \over {N / 2}} n} \color{red}{+} e^{- j 2 \pi {k \over N}} \sum_{n = 0}^{{N \over 2} - 1} x[2n + 1] e^{- j 2 \pi {k \over {N / 2}} n} \\
    X\left[k + {N \over 2}\right] &amp;= \sum_{n = 0}^{{N \over 2} - 1} x[2n] e^{- j 2 \pi {k \over {N / 2}} n} \color{red}{-} e^{- j 2 \pi {k \over N}} \sum_{n = 0}^{{N \over 2} - 1} x[2n + 1] e^{- j 2 \pi {k \over {N / 2}} n} \\
\end{align}</p>
<p>很显然这是个递归的思想。如果$x[2n]$的长度不是2，那么还可以继续把$x[2n]$分解成$x[4n], x[4n + 2]$，把$x[2n + 1]$分解成$x[4n + 1], x[4n + 3]$。直到最后都变成长度为2的序列。因为长度为2的序列的DFT非常简单，就是加减
\begin{align}
    X_0 &amp;= x_0 + x_1 \\
    X_1 &amp;= x_0 - x_1
\end{align}
也可以写成矩阵形式
\begin{align}
    \vec{X} = \left(\begin{matrix}
        1 &amp; 1 \\
        1 &amp; -1 \\
    \end{matrix}\right) \cdot \vec{x}
\end{align}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="$N-=-8$&#30340;&#20363;&#23376;">$N = 8$&#30340;&#20363;&#23376;<a class="anchor-link" href="#$N-=-8$&#30340;&#20363;&#23376;">&#182;</a></h4><p>$N = 8$时，
\begin{align}
    \vec{x} = (\begin{matrix}
        x_0 &amp; x_1 &amp; x_2 &amp; x_3 &amp; x_4 &amp; x_5 &amp; x_6 &amp; x_7
    \end{matrix})^T
\end{align}
先切成
\begin{align}
    \vec{x}_1 &amp;= (\begin{matrix}
        x_0 &amp; x_2 &amp; x_4 &amp; x_6
    \end{matrix})^T \\
    \vec{x}_2 &amp;= (\begin{matrix}
        x_1 &amp; x_3 &amp; x_5 &amp; x_7
    \end{matrix})^T \\
\end{align}
可以看到$\vec{x}_1$中的元素全部都是$\vec{x}$里下标为偶数的元素，$\vec{x}_2$中的元素全部都是$\vec{x}$里下标为奇数的元素。</p>
<p>再切成
\begin{align}
    \vec{x}_{1, 1} &amp;= (\begin{matrix}
        x_0 &amp; x_4
    \end{matrix})^T \\
    \vec{x}_{1, 2} &amp;= (\begin{matrix}
        x_2 &amp; x_6
    \end{matrix})^T \\
    \vec{x}_{2, 1} &amp;= (\begin{matrix}
        x_1 &amp; x_5
    \end{matrix})^T \\
    \vec{x}_{2, 2} &amp;= (\begin{matrix}
        x_3 &amp; x_7
    \end{matrix})^T \\
\end{align}
可以看到$\vec{x}_{1, 1}$中的元素全部都是$\vec{x}_1$里下标为偶数的元素，$\vec{x}_{1, 2}$中的元素全部都是$\vec{x}_1$里下标为奇数的元素。对于$\vec{x}_{2, 1}, \vec{x}_{2, 2}$同理。</p>
<p>\begin{align}
    &amp; \begin{aligned}
        &amp; \begin{aligned}
            &amp; \left(\begin{matrix}
                x_0 \\
                x_4 \\
            \end{matrix}\right) &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
                x_0 \\
                x_4 \\
            \end{matrix}\right) \\
            \\
            &amp; \left(\begin{matrix}
                x_2 \\
                x_6 \\
            \end{matrix}\right) &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
                x_2 \\
                x_6 \\
            \end{matrix}\right) \\
            \\
        \end{aligned} &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
                x_0 \\
                x_2 \\
                x_4 \\
                x_6 \\
            \end{matrix}\right) \\
        &amp; \begin{aligned}
            &amp; \left(\begin{matrix}
                x_1 \\
                x_5 \\
            \end{matrix}\right) &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
                x_1 \\
                x_5 \\
            \end{matrix}\right) \\
            \\
            &amp; \left(\begin{matrix}
                x_3 \\
                x_7 \\
            \end{matrix}\right) &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
                x_3 \\
                x_7 \\
            \end{matrix}\right) \\
            \\
        \end{aligned} &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
                x_1 \\
                x_3 \\
                x_5 \\
                x_7 \\
            \end{matrix}\right) \\
    \end{aligned} &amp;&amp; \longrightarrow &amp;&amp; \operatorname{DFT} \left(\begin{matrix}
        x_0 \\
        x_1 \\
        x_2 \\
        x_3 \\
        x_4 \\
        x_5 \\
        x_6 \\
        x_7 \\
    \end{matrix}\right)
\end{align}
图中的箭头"$\longrightarrow$"都是指<strong>蝴蝶型运算。</strong></p>
<blockquote><p>为什么输出是自然顺序<code>0 1 2 ... 7</code>但是输入不是呢？输入的顺序怎么得到？</p>
<p>做法很简单，就是把自然顺序的<code>0 1 2 ... 7</code>写成二进制<code>000 001 010 ... 111</code>，然后，每个数字的二进制倒过来，变成<code>000 100 010 ... 111</code>，就成为输入下标的顺序。</p>
<p>\begin{align}
    &amp; {\rm 十进制} &amp;&amp; {\rm 二进制} &amp;&amp; {\rm 二进制倒序} &amp;&amp; {\rm 二进制倒序转十进制} \\
    &amp; 0 &amp;&amp; 000 &amp;&amp; 000 &amp;&amp; 0 \\
    &amp; 1 &amp;&amp; 001 &amp;&amp; 100 &amp;&amp; 4 \\
    &amp; 2 &amp;&amp; 010 &amp;&amp; 010 &amp;&amp; 2 \\
    &amp; 3 &amp;&amp; 011 &amp;&amp; 110 &amp;&amp; 6 \\
    &amp; 4 &amp;&amp; 100 &amp;&amp; 001 &amp;&amp; 1 \\
    &amp; 5 &amp;&amp; 101 &amp;&amp; 101 &amp;&amp; 5 \\
    &amp; 6 &amp;&amp; 110 &amp;&amp; 011 &amp;&amp; 3 \\
    &amp; 7 &amp;&amp; 111 &amp;&amp; 111 &amp;&amp; 7
\end{align}</p>
<p>这里可以详细运算Coolkey-Tukey算法的时间复杂度。以蝴蝶型运算为单位。我们发现一个"蝴蝶结"需要作1次复数乘法、2次复数加法，等价于4次实数乘法、6次实数加法。对于长度为$N$的序列，会有$\log_2 N$<strong>级</strong>蝴蝶结，每一<strong>级</strong>蝴蝶结里面都有${N \over 2}$<strong>个</strong>蝴蝶结，所以一共有
\begin{align}
    {N \over 2} \log_2 N
\end{align}
个蝴蝶结。所以对于$N$长度的序列，用Coolkey-Tukey算法，需要作$2 N \log_2 N$次实数乘法、$3 N \log_2 N$次实数加法，时间复杂度是$O(n \log_2 n)$。和常规方法比较，是数量级级的效率提升。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">W</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="p">(</span><span class="o">-</span> <span class="mi">1j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fft2</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">x0</span> <span class="o">+</span> <span class="n">x1</span><span class="p">,</span> <span class="c1"># X0</span>
        <span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="c1"># X1</span>
    <span class="p">]</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fft4</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">):</span>
    <span class="n">_X0</span><span class="p">,</span> <span class="n">_X2</span> <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">_X1</span><span class="p">,</span> <span class="n">_X3</span> <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x3</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span>
        <span class="n">_X0</span> <span class="o">+</span> <span class="n">_X1</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># X0</span>
        <span class="n">_X2</span> <span class="o">+</span> <span class="n">_X3</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># X1</span>
        <span class="n">_X0</span> <span class="o">-</span> <span class="n">_X1</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># X2</span>
        <span class="n">_X2</span> <span class="o">-</span> <span class="n">_X3</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># X3</span>
    <span class="p">]</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fft8</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">,</span> <span class="n">x7</span><span class="p">):</span>
    <span class="n">_X0</span><span class="p">,</span> <span class="n">_X2</span><span class="p">,</span> <span class="n">_X4</span><span class="p">,</span> <span class="n">_X6</span> <span class="o">=</span> <span class="n">fft4</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">x6</span><span class="p">)</span>
    <span class="n">_X1</span><span class="p">,</span> <span class="n">_X3</span><span class="p">,</span> <span class="n">_X5</span><span class="p">,</span> <span class="n">_X7</span> <span class="o">=</span> <span class="n">fft4</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x5</span><span class="p">,</span> <span class="n">x7</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span>
        <span class="n">_X0</span> <span class="o">+</span> <span class="n">_X1</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># X0</span>
        <span class="n">_X2</span> <span class="o">+</span> <span class="n">_X3</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># X1</span>
        <span class="n">_X4</span> <span class="o">+</span> <span class="n">_X5</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="c1"># X2</span>
        <span class="n">_X6</span> <span class="o">+</span> <span class="n">_X7</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="c1"># X3</span>
        <span class="n">_X0</span> <span class="o">-</span> <span class="n">_X1</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># X4</span>
        <span class="n">_X2</span> <span class="o">-</span> <span class="n">_X3</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># X5</span>
        <span class="n">_X4</span> <span class="o">-</span> <span class="n">_X5</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="c1"># X6</span>
        <span class="n">_X6</span> <span class="o">-</span> <span class="n">_X7</span> <span class="o">*</span> <span class="n">W</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="c1"># X7</span>
    <span class="p">]</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Sander-Tukey&#31639;&#27861;-aka.-DIF&#31639;&#27861;">Sander-Tukey&#31639;&#27861; aka. DIF&#31639;&#27861;<a class="anchor-link" href="#Sander-Tukey&#31639;&#27861;-aka.-DIF&#31639;&#27861;">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="IFFT">IFFT<a class="anchor-link" href="#IFFT">&#182;</a></h2><p>观察DFT的分析公式和综合公式
\begin{align}
    X[k] &amp;= \sum_{n = 0}^{N - 1} x[n] e^{\color{red}{-} j 2 \pi {k \over N} n} \\
    x[n] &amp;= \color{red}{1 \over N} \sum_{n = 0}^{N - 1} X[k] e^{\color{red}{+} j 2 \pi {k \over N} n}
\end{align}
发现DFT和IDFT的差别仅仅就在于</p>
<ul>
<li>综合公式比分析公式多了一个系数${1 \over N}$</li>
<li>综合公式里的指数是$+$，分析公式里的指数是$-$</li>
</ul>
<p>所以有两种办法来做IFFT。</p>
<h3 id="&#25913;&#34676;&#34678;&#32467;&#30340;&#20056;&#31995;&#25968;+&#26368;&#21518;&#38500;&#20197;$N$">&#25913;&#34676;&#34678;&#32467;&#30340;&#20056;&#31995;&#25968;+&#26368;&#21518;&#38500;&#20197;$N$<a class="anchor-link" href="#&#25913;&#34676;&#34678;&#32467;&#30340;&#20056;&#31995;&#25968;+&#26368;&#21518;&#38500;&#20197;$N$">&#182;</a></h3><p>把Coolkey-Tukey中的每个蝴蝶结左下方的相乘系数从$\omega_{N}^{nk}$改成$\omega_{N}^{-nk}$，再在最后乘以一个系数${1 \over N}$。</p>
<blockquote><p>再次注意$\omega_{N}^{kn}$的定义是$e^{-j 2 \pi {k \over N} n}$。</p>
</blockquote>
<p>这样IFFT和FFT的程序其实有很大不同了。</p>
<h3 id="&#36755;&#20837;&#20808;&#21462;&#20849;&#36717;+&#26368;&#21518;&#38500;&#20197;$N$">&#36755;&#20837;&#20808;&#21462;&#20849;&#36717;+&#26368;&#21518;&#38500;&#20197;$N$<a class="anchor-link" href="#&#36755;&#20837;&#20808;&#21462;&#20849;&#36717;+&#26368;&#21518;&#38500;&#20197;$N$">&#182;</a></h3><p>这种方法<strong>不需要改程序</strong>，只需要在FFT的程序前面插入一个<strong>对输入逐个取共轭</strong>的程序、在FFT程序的最后追加一个取共轭、一个<strong>除以$N$</strong>的程序就可以了。</p>
<p>原理非常简单。观察综合公式
\begin{align}
    x[n] = {1 \over N} \sum_{n = 0}^{N - 1} X[k] e^{j 2 \pi {k \over N} n} \\
\end{align}
右边取两次共轭，交换共轭和求和次序
\begin{align}
    x[n] &amp;= {1 \over N} \left[\sum_{n = 0}^{N - 1} (X[k] e^{j 2 \pi {k \over N} n} )^*\right]^*\\
    &amp;= {1 \over N} \left(\underbrace{\sum_{n = 0}^{N - 1} X[k]^* e^{- j 2 \pi {k \over N} n}}_{\operatorname{DFT}(X[k]^*) }\right)^*\\
\end{align}
可见只要给一个FFT程序输入$X[k]^*$、再给结果取共轭、除以$N$就可以了。非常方便。</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="&#25968;&#23383;&#28388;&#27874;&#22120;">&#25968;&#23383;&#28388;&#27874;&#22120;<a class="anchor-link" href="#&#25968;&#23383;&#28388;&#27874;&#22120;">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#35774;&#35745;&#26041;&#27861;">&#35774;&#35745;&#26041;&#27861;<a class="anchor-link" href="#&#35774;&#35745;&#26041;&#27861;">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#20914;&#20987;&#21709;&#24212;&#19981;&#21464;&#27861;">&#20914;&#20987;&#21709;&#24212;&#19981;&#21464;&#27861;<a name="sec:impulse-invariance" /><a class="anchor-link" href="#&#20914;&#20987;&#21709;&#24212;&#19981;&#21464;&#27861;">&#182;</a></h4><p>使数字滤波器的单位冲激响应$h[n]$处处等于对应模拟滤波器的单位冲击响应的采样点$h(n T_s)$
\begin{align}
    \forall n \in Z: \qquad h[n] = h(n T_s)
\end{align}
即
\begin{align}
    \forall n \in Z: \qquad \int_{- {1 \over 2}}^{1 \over 2} H(e^{j 2 \pi f}) e^{j 2 \pi f n} \,df = \int_{- \infty}^{+ \infty} H(j 2 \pi f) e^{j 2 \pi f n T_s} \,df
\end{align}
但是从上面的这个关系，看不出频谱$H(e^{j 2 \pi f})$和$H(j 2 \pi f)$之间的关系。</p>
<blockquote><p>时刻记住我们的目的：把模拟滤波器的频谱$H(j 2 \pi f)$转换到数字滤波器的频谱$H(e^{j 2 \pi f})$。所以一定要得到用$H(j 2 \pi f)$表示的$H(e^{j 2 \pi f})$。</p>
</blockquote>
<p>回想<a href="#sec:sampling">采样章节</a>，我们发现这个好像就是$x[n] = x(n T_s)$的定义式。而且实际采样$x[n] = x(n T_s)$的频谱和理想采样$\hat{x}(t)$的频谱好像是有某种关联的。这个关联可以写成
\begin{align}
    H(e^{j 2 \pi f}) = \hat{H}(j 2 \pi {f \over T_s})
\end{align}</p>
<p>再把几个频谱关系放在一起观察
\begin{align}
    &amp; h[n] &amp;&amp; \mathop{\longleftrightarrow}^{\rm DTFT} &amp;&amp; H(e^{j 2 \pi f}) \\
    &amp; h(t) &amp;&amp; \mathop{\longleftrightarrow}^{\rm CTFT} &amp;&amp; H(j 2 \pi f) \\
    &amp; \hat{h}(t) = \sum_{n = -\infty}^{+\infty} h(t) \delta(t - n T_s) &amp;&amp; \mathop{\longleftrightarrow}^{\rm CTFT} &amp;&amp; \hat{H}(j 2 \pi f) = {1 \over T_s} \sum_{n = -\infty}^{+\infty} H\left(j 2 \pi \left(f - {n \over T_s}\right)\right)
\end{align}
把上面的关联带入最后一个式子，得到
\begin{align}
    H(e^{j 2 \pi f}) = {1 \over T_s} \sum_{n = -\infty}^{+\infty} H\underbrace{\left(j 2 \pi \left({f \over T_s} - {n \over T_s}\right)\right)}_{横向缩放、平移}
\end{align}</p>
<p>很显然，把设计好的模拟滤波器的频率响应函数先横向伸缩变换、再复制搬移，就得到了数字滤波器的频率响应函数。</p>
<p>但是用传输函数更方便，所以</p>
<blockquote><p>这里推导用的全是频率响应函数而不是传输函数。我觉得也可以一开始就用传输函数推导，即从$s$变换推到$z$变换。</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="&#21452;&#32447;&#24615;&#21464;&#25442;&#27861;">&#21452;&#32447;&#24615;&#21464;&#25442;&#27861;<a class="anchor-link" href="#&#21452;&#32447;&#24615;&#21464;&#25442;&#27861;">&#182;</a></h4>
</div>
</div>
</div>
 

