<div class="cell border-box-sizing text_cell rendered">
    <div class="prompt input_prompt">
    </div>
    <div class="inner_cell">
        <div class="text_cell_render border-box-sizing rendered_html">
            <h1 class="title">leetcode备忘录</h1>
            
            <div class="admonition note">
<p class="admonition-title">注解</p>
<p>前情提要</p>
<p>前大概200题在我<a class="reference external" href="http://aiifabbf.github.io/leetcode中的算法">博客</a>上。</p>
<p>二刷的时候都会整理到这里来。</p>
</div>
<div class="contents topic" id="id2">
<p class="topic-title first">目录</p>
<ul class="auto-toc simple">
<li><p><a class="reference internal" href="#id3" id="id19"><span class="sectnum">1</span> 未解决</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id20"><span class="sectnum">2</span> 可优化</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id21"><span class="sectnum">3</span> 一些思路</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#array" id="id22"><span class="sectnum">3.1</span> array中的目标函数优化问题</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id6" id="id23"><span class="sectnum">4</span> 一些模板</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#arrayarraysubsequence" id="id24"><span class="sectnum">4.1</span> 判断一个array是不是另一个array的subsequence（可以不连续）</a></p></li>
<li><p><a class="reference internal" href="#arrayarraysubstring" id="id25"><span class="sectnum">4.2</span> 判断一个array是不是另一个array的substring（连续）</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id26"><span class="sectnum">4.3</span> 二叉树的先根遍历</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id27"><span class="sectnum">4.4</span> 二叉树的中根遍历</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id28"><span class="sectnum">4.5</span> 二叉树的后根遍历</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id29"><span class="sectnum">4.6</span> 树的广度优先遍历</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id30"><span class="sectnum">4.7</span> 二叉树的广度优先遍历</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id31"><span class="sectnum">4.8</span> 得到二叉树的深度</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id32"><span class="sectnum">4.9</span> 取得二叉树的所有叶子节点值</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id33"><span class="sectnum">4.10</span> 取得二叉树里根节点到所有叶子的路径</a></p></li>
<li><p><a class="reference internal" href="#bst" id="id34"><span class="sectnum">4.11</span> 判断二叉树是不是二分搜索树（BST）</a></p></li>
<li><p><a class="reference internal" href="#arrayheight-balanced-bst" id="id35"><span class="sectnum">4.12</span> 排好序的array转换到height-balanced BST</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id36"><span class="sectnum">4.13</span> 筛选出出现频次最高的元素</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id37"><span class="sectnum">4.14</span> 计算器</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h1><a class="toc-backref" href="#id19"><span class="sectnum">1</span> 未解决</a></h1>
<ul class="simple">
<li><p>743</p></li>
<li><p>713</p></li>
<li><p>475</p></li>
<li><p>784</p></li>
<li><p>399</p></li>
<li><p>866 找不小于n的最小回文素数</p></li>
<li><p>491 找数组的递增subsequence</p></li>
<li><p>223 找出两个矩形的相交区域的面积</p></li>
<li><p>805 拆数组，拆成两个平均值相同的数组</p></li>
<li><p>835 平移找矩阵最大重合面积</p></li>
<li><p>994 元胞自动机</p></li>
<li><p>436 寻找区间列里比现在这个大的最小的区间</p></li>
<li><p>958 判断二叉树是不是完全二叉树</p></li>
<li><p>662 二叉树的最大宽度</p></li>
<li><p>449 序列化、反序列化二叉树的方法</p></li>
<li><p>406</p></li>
<li><p>898</p></li>
<li><p>863</p></li>
<li><p>1015</p></li>
</ul>
</div>
<div class="section" id="id4">
<h1><a class="toc-backref" href="#id20"><span class="sectnum">2</span> 可优化</a></h1>
<ul class="simple">
<li><p>523 找substring能否累加得到k的整数倍</p></li>
<li><p>653 二分搜索树中的two sum</p></li>
<li><p>671 找到一个满足一些特殊性质的二叉树里的倒数第二小的节点值</p></li>
<li><p>543 二叉树里任意两点之间的距离的最大值</p></li>
<li><p>235 在二分搜索树里找到两个节点的最近公共祖先节点</p></li>
<li><p>222 数出一个完全二叉树里的节点个数</p></li>
<li><p>88  合并两个从小到大排好序的array</p></li>
</ul>
</div>
<div class="section" id="id5">
<h1><a class="toc-backref" href="#id21"><span class="sectnum">3</span> 一些思路</a></h1>
<div class="section" id="array">
<h2><a class="toc-backref" href="#id22"><span class="sectnum">3.1</span> array中的目标函数优化问题</a></h2>
</div>
</div>
<div class="section" id="id6">
<h1><a class="toc-backref" href="#id23"><span class="sectnum">4</span> 一些模板</a></h1>
<div class="section" id="arrayarraysubsequence">
<h2><a class="toc-backref" href="#id24"><span class="sectnum">4.1</span> 判断一个array是不是另一个array的subsequence（可以不连续）</a></h2>
<pre class="code python literal-block"><code><span class="keyword">def</span> <span class="name function">isSubArray</span><span class="punctuation">(</span><span class="name">subarray</span><span class="punctuation">,</span> <span class="name">array</span><span class="punctuation">):</span>
    <span class="name">pos</span> <span class="operator">=</span> <span class="operator">-</span><span class="literal number integer">1</span>
    <span class="keyword">for</span> <span class="name">i</span> <span class="operator word">in</span> <span class="name">subarray</span><span class="punctuation">:</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="name">pos</span> <span class="operator">=</span> <span class="name">array</span><span class="operator">.</span><span class="name">index</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">,</span> <span class="name">start</span><span class="operator">=</span><span class="name">pos</span> <span class="operator">+</span> <span class="literal number integer">1</span><span class="punctuation">)</span>
        <span class="keyword">except</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="name builtin pseudo">False</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="name builtin pseudo">True</span></code></pre>
</div>
<div class="section" id="arrayarraysubstring">
<h2><a class="toc-backref" href="#id25"><span class="sectnum">4.2</span> 判断一个array是不是另一个array的substring（连续）</a></h2>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id26"><span class="sectnum">4.3</span> 二叉树的先根遍历</a></h2>
<p>可以用递归</p>
<pre class="code python literal-block"><code><span class="comment single"># 改编自144</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">preorderTraversal</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">int</span><span class="punctuation">]:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="name">doSomthing</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">)</span> <span class="comment single"># 比如放入数组之类的</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">preorderTraversal</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span>
                <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">preorderTraversal</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">pass</span></code></pre>
<p>也可以用迭代、借助stack。好处有两个</p>
<ul class="simple">
<li><p>速度快一点</p></li>
<li><p>不受递归深度限制</p></li>
</ul>
<pre class="code python literal-block"><code><span class="comment single"># 改编自144</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">preorderTraversal</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">int</span><span class="punctuation">]:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="name">res</span> <span class="operator">=</span> <span class="punctuation">[]</span>
            <span class="name">stack</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="name">root</span><span class="punctuation">]</span>

            <span class="keyword">while</span> <span class="name">stack</span><span class="punctuation">:</span>
                <span class="name">node</span> <span class="operator">=</span> <span class="name">stack</span><span class="operator">.</span><span class="name">pop</span><span class="punctuation">()</span>
                <span class="name">res</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">node</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">)</span> <span class="comment single"># 这里相当于访问node</span>
                <span class="keyword">if</span> <span class="name">node</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span> <span class="comment single"># 这里要记住是右边先进stack</span>
                    <span class="name">stack</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">node</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
                <span class="keyword">if</span> <span class="name">node</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                    <span class="name">stack</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">node</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>

            <span class="keyword">return</span> <span class="name">res</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="punctuation">[]</span></code></pre>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>先根遍历路径的特点</p>
<p>先根遍历路径的第一个元素永远是根节点，然后接下来是左边子树、右边子树。图像类似这样</p>
<pre class="literal-block">o [     ] (     )
------------------
0 1     ? ?      n</pre>
<p>所以除了能确定第一个元素是根节点，其他的信息比如</p>
<ul class="simple">
<li><p>第二个元素开始是属于左边子树还是右边子树？</p></li>
<li><p>从第几个元素开始是左边子树和右边子树的边界？</p></li>
<li><p>...</p></li>
</ul>
<p>都是不知道的。</p>
</div>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id27"><span class="sectnum">4.4</span> 二叉树的中根遍历</a></h2>
<p>可以用递归，只要把对根节点的访问的语句放到中间就算中根遍历了。</p>
<pre class="code python literal-block"><code><span class="comment single"># 改编自94</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">inorderTraversal</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">int</span><span class="punctuation">]:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">inorderTraversal</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>
            <span class="name">doSomthing</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">)</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span>
                <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">inorderTraversal</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">pass</span></code></pre>
<p>也可以借助stack，然后迭代，但是写起来挺麻烦的……</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>二分搜索树（BST）用中根遍历之后，会得到排好序的array。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>中根遍历路径的特点</p>
<p>中根遍历路径的第一个元素可能是左边子树、也可能是根节点（如果左边子树不存在的话）。图像类似这样</p>
<pre class="literal-block">[       ] o (       )
---------------------
0         ? ?        n</pre>
<p>所以单靠中根遍历路径其实不能得到什么有用的信息。</p>
<p>但是如果中根遍历路径和先根遍历路径同时给出（105题）、或者中根遍历路径和后根遍历路径同时给出（106题），就可以还原出树本来的结构。</p>
<p>以中根遍历路径和先根遍历路径为例，</p>
<ol class="arabic">
<li><p>中根遍历路径的第一个元素肯定是根节点的值。</p></li>
<li><p>在先根遍历路径里找到根节点的值的位置，这样就能知道</p>
<ul class="simple">
<li><p>在这之前的所有元素都是属于左边子树的，且左边子树的节点个数也是知道的。</p></li>
<li><p>在这之后的所有元素都是属于右边子树的，且右边子树的节点个数也是知道的。</p></li>
</ul>
<p>再回到中根遍历路径里，因为左边子树的节点个数知道了（假设是n），所以中根遍历路径里从第2个元素到第2 + n - 1个元素是属于左边子树的，从第2 + n个元素一直到最后都是属于右边子树的。</p>
</li>
<li><p>递归地把左边子树、右边子树的结构按同样的方法恢复出来。</p></li>
</ol>
</div>
<p>衍生</p>
<ul class="simple">
<li><p>105 从中根、先根遍历路径中恢复出二叉树</p></li>
<li><p>106 从中根、后根遍历路径中恢复出二叉树</p></li>
<li><p>889 从先根、后根遍历路径中恢复出二叉树的一种可能</p></li>
</ul>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id28"><span class="sectnum">4.5</span> 二叉树的后根遍历</a></h2>
<pre class="code python literal-block"><code><span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">postorderTraversal</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">int</span><span class="punctuation">]:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">postorderTraversal</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span>
                <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">postorderTraversal</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
            <span class="name">doSomthing</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">pass</span></code></pre>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id29"><span class="sectnum">4.6</span> 树的广度优先遍历</a></h2>
<pre class="code python literal-block"><code><span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">levelOrder</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="literal string single">'Node'</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="name">queue</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="name">root</span><span class="punctuation">]</span>
            <span class="keyword">while</span> <span class="name">queue</span><span class="punctuation">:</span>
                <span class="name">element</span> <span class="operator">=</span> <span class="name">queue</span><span class="operator">.</span><span class="name">pop</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">)</span>
                <span class="name">doSomething</span><span class="punctuation">(</span><span class="name">element</span><span class="punctuation">)</span>
                <span class="name">queue</span> <span class="operator">+=</span> <span class="name">element</span><span class="operator">.</span><span class="name">children</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">pass</span></code></pre>
<div class="admonition note" id="id11">
<p class="admonition-title">注解</p>
<p>树的广度优先、按层遍历</p>
<p>如果想一层一层遍历，可以不要直接把下一层的所有children都放到queue里，而是暂时先放到一个临时queue里面，等这一层完了，再把临时queue整个替换掉全局的那个queue。比如下面这个例子</p>
<pre class="code python literal-block"><code><span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">maxDepth</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="literal string single">'Node'</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin">int</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="name">depth</span> <span class="operator">=</span> <span class="literal number integer">1</span>
            <span class="name">queue</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="name">root</span><span class="punctuation">]</span>
            <span class="keyword">while</span> <span class="name">queue</span><span class="punctuation">:</span>
                <span class="name">levelQueue</span> <span class="operator">=</span> <span class="name builtin">sum</span><span class="punctuation">((</span><span class="name">i</span><span class="operator">.</span><span class="name">children</span> <span class="keyword">for</span> <span class="name">i</span> <span class="operator word">in</span> <span class="name">queue</span><span class="punctuation">),</span> <span class="punctuation">[])</span>
                <span class="name">queue</span> <span class="operator">=</span> <span class="name">levelQueue</span>
                <span class="name">depth</span> <span class="operator">+=</span> <span class="literal number integer">1</span>
            <span class="keyword">return</span> <span class="name">depth</span> <span class="operator">-</span> <span class="literal number integer">1</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="literal number integer">0</span></code></pre>
</div>
</div>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id30"><span class="sectnum">4.7</span> 二叉树的广度优先遍历</a></h2>
<pre class="code python literal-block"><code><span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">maxDepth</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin">int</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="name">queue</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="name">root</span><span class="punctuation">]</span>

            <span class="keyword">while</span> <span class="name">queue</span><span class="punctuation">:</span>
                <span class="name">i</span> <span class="operator">=</span> <span class="name">queue</span><span class="operator">.</span><span class="name">pop</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">)</span>
                <span class="keyword">if</span> <span class="name">i</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                    <span class="name">queue</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>
                <span class="keyword">if</span> <span class="name">i</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span> <span class="comment single"># 切记切记这里不是elif，是if，因为左边和右边根本没关系</span>
                    <span class="name">queue</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
                <span class="name">doSomething</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">)</span>

        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">pass</span></code></pre>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>二叉树的广度优先、按层遍历</p>
<p>如果想一层一层遍历，和 <a class="reference internal" href="#id11">树的广度优先、按层遍历</a> 一样。</p>
<pre class="code python literal-block"><code><span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">maxDepth</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin">int</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="name">depth</span> <span class="operator">=</span> <span class="literal number integer">1</span>
            <span class="name">queue</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="name">root</span><span class="punctuation">]</span>
            <span class="keyword">while</span> <span class="name">queue</span><span class="punctuation">:</span>
                <span class="name">levelQueue</span> <span class="operator">=</span> <span class="punctuation">[]</span>
                <span class="keyword">for</span> <span class="name">i</span> <span class="operator word">in</span> <span class="name">queue</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="name">i</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                        <span class="name">levelQueue</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>
                    <span class="keyword">if</span> <span class="name">i</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span> <span class="comment single"># 切记切记这里不是elif，是if，因为左边和右边根本没关系</span>
                        <span class="name">levelQueue</span><span class="operator">.</span><span class="name">append</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
                <span class="name">depth</span> <span class="operator">+=</span> <span class="literal number integer">1</span>
                <span class="name">queue</span> <span class="operator">=</span> <span class="name">levelQueue</span>
            <span class="keyword">return</span> <span class="name">depth</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="literal number integer">0</span></code></pre>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果一个二叉树是 <a class="reference external" href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">完全二叉树</a> 的话，那么对这个完全二叉树的广度优先遍历有一个性质：如果遇到一个节点是null，那么以后就不再会遇到非null节点。</p>
<p>而且这条性质是充分必要的，如果一个树不是完全二叉树，那么它不会满足这条性质；如果一个树是完全二叉树，那么它一定满足这条性质。</p>
<p>958题里我利用了这条性质。</p>
</div>
<p>衍生</p>
<ul class="simple">
<li><p>103 二叉树的zigzag遍历</p></li>
<li><p>513 二叉树最后一层的最左边节点的值</p></li>
<li><p>515 二叉树最后一层的最大节点值</p></li>
</ul>
</div>
<div class="section" id="id14">
<h2><a class="toc-backref" href="#id31"><span class="sectnum">4.8</span> 得到二叉树的深度</a></h2>
<p>以前一直是用广度优先、按层遍历来做的（104题），但是也有非常简单的写法，比如</p>
<pre class="code python literal-block"><code><span class="comment single"># 摘自543</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">maxDepth</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin">int</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="literal number integer">1</span> <span class="operator">+</span> <span class="name builtin">max</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">maxDepth</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">),</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">maxDepth</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">))</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="literal number integer">0</span></code></pre>
<p>不一定比按层遍历快，但是写起来足够简单。</p>
</div>
<div class="section" id="id15">
<h2><a class="toc-backref" href="#id32"><span class="sectnum">4.9</span> 取得二叉树的所有叶子节点值</a></h2>
<pre class="code python literal-block"><code><span class="comment single"># 摘自872</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">getLeaves</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">int</span><span class="punctuation">]:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="punctuation">[</span><span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">]</span>
            <span class="name">res</span> <span class="operator">=</span> <span class="punctuation">[]</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">:</span>
                <span class="name">res</span> <span class="operator">+=</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">getLeaves</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">:</span>
                <span class="name">res</span> <span class="operator">+=</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">getLeaves</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)</span>
            <span class="keyword">return</span> <span class="name">res</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="punctuation">[]</span></code></pre>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id33"><span class="sectnum">4.10</span> 取得二叉树里根节点到所有叶子的路径</a></h2>
<p>还是一个递归的思路。</p>
<p>一个二叉树根节点到所有叶子的路径，等于</p>
<ul class="simple">
<li><p>左边子二叉树里根节点到所有叶子的路径</p></li>
<li><p>右边子二叉树里根节点到所有叶子的路径</p></li>
</ul>
<p>加上根节点到左边子节点、根节点到右边子节点的两条路。</p>
<pre class="code python literal-block"><code><span class="comment single"># 摘自257</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">binaryTreePaths</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">str</span><span class="punctuation">]:</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span> <span class="comment single"># 叶子</span>
                <span class="keyword">return</span> <span class="punctuation">[</span><span class="name">f</span><span class="literal string double">&quot;{root.val}&quot;</span><span class="punctuation">]</span>
            <span class="keyword">elif</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">!=</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="punctuation">[</span><span class="name">f</span><span class="literal string double">&quot;{root.val}-&gt;{i}&quot;</span> <span class="keyword">for</span> <span class="name">i</span> <span class="operator word">in</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">binaryTreePaths</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)]</span> <span class="comment single"># 根节点出发到左边子节点、加上左边子二叉树里根节点到所有叶子的路径</span>
            <span class="keyword">elif</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">!=</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="punctuation">[</span><span class="name">f</span><span class="literal string double">&quot;{root.val}-&gt;{i}&quot;</span> <span class="keyword">for</span> <span class="name">i</span> <span class="operator word">in</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">binaryTreePaths</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)]</span> <span class="comment single"># 根节点出发到右边子节点、加上右边子二叉树里根节点到所有叶子的路径</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="punctuation">[</span><span class="name">f</span><span class="literal string double">&quot;{root.val}-&gt;{i}&quot;</span> <span class="keyword">for</span> <span class="name">i</span> <span class="operator word">in</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">binaryTreePaths</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">binaryTreePaths</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">)]</span> <span class="comment single"># 左右都加</span>
        <span class="keyword">else</span><span class="punctuation">:</span> <span class="comment single"># 空节点</span>
            <span class="keyword">return</span> <span class="punctuation">[]</span> <span class="comment single"># 无路可走</span></code></pre>
<p>衍生</p>
<ul class="simple">
<li><p>129</p></li>
<li><p>988</p></li>
<li><p>113</p></li>
</ul>
</div>
<div class="section" id="bst">
<h2><a class="toc-backref" href="#id34"><span class="sectnum">4.11</span> 判断二叉树是不是二分搜索树（BST）</a></h2>
<pre class="code python literal-block"><code><span class="comment single"># 摘自98</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">isValidBST</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin">bool</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">isBST</span><span class="punctuation">(</span><span class="name">root</span><span class="punctuation">,</span> <span class="name builtin">float</span><span class="punctuation">(</span><span class="literal string double">&quot;-inf&quot;</span><span class="punctuation">),</span> <span class="name builtin">float</span><span class="punctuation">(</span><span class="literal string double">&quot;inf&quot;</span><span class="punctuation">))</span>

    <span class="keyword">def</span> <span class="name function">isBST</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">root</span><span class="punctuation">:</span> <span class="name">TreeNode</span><span class="punctuation">,</span> <span class="name">lower</span><span class="punctuation">:</span> <span class="name builtin">int</span><span class="punctuation">,</span> <span class="name">upper</span><span class="punctuation">:</span> <span class="name builtin">int</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name builtin">bool</span><span class="punctuation">:</span> <span class="comment single"># 除了root还要传入上下界</span>
        <span class="keyword">if</span> <span class="name">root</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span> <span class="operator">&gt;</span> <span class="name">lower</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span> <span class="operator">&lt;</span> <span class="name">upper</span><span class="punctuation">:</span> <span class="comment single"># 首先根节点要在上下界之内</span>
                <span class="keyword">if</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">!=</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span> <span class="comment single"># 左边子树非空、右边子树空</span>
                    <span class="keyword">return</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="operator">.</span><span class="name">val</span> <span class="operator">&lt;</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span> <span class="operator word">and</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">isBST</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">,</span> <span class="name">lower</span><span class="punctuation">,</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">)</span> <span class="comment single"># 下界不变，上界变成根节点的值</span>
                <span class="keyword">elif</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">==</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">!=</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span> <span class="comment single"># 左边子树空、右边子树非空</span>
                    <span class="keyword">return</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="operator">.</span><span class="name">val</span> <span class="operator">&gt;</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span> <span class="operator word">and</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">isBST</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">,</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">,</span> <span class="name">upper</span><span class="punctuation">)</span> <span class="comment single"># 下界变成根节点的值，上界不变</span>
                <span class="keyword">elif</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">!=</span> <span class="name builtin pseudo">None</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">!=</span> <span class="name builtin pseudo">None</span><span class="punctuation">:</span>
                    <span class="keyword">return</span> <span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="operator">.</span><span class="name">val</span> <span class="operator">&lt;</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span> <span class="operator word">and</span> <span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="operator">.</span><span class="name">val</span> <span class="operator">&gt;</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span> <span class="operator word">and</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">isBST</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">left</span><span class="punctuation">,</span> <span class="name">lower</span><span class="punctuation">,</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">)</span> <span class="operator word">and</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">isBST</span><span class="punctuation">(</span><span class="name">root</span><span class="operator">.</span><span class="name">right</span><span class="punctuation">,</span> <span class="name">root</span><span class="operator">.</span><span class="name">val</span><span class="punctuation">,</span> <span class="name">upper</span><span class="punctuation">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="keyword">return</span> <span class="name builtin pseudo">True</span>
            <span class="keyword">else</span><span class="punctuation">:</span> <span class="comment single"># 不然即使自己是BST，作为子树放在上层里也不能使大树是BST</span>
                <span class="keyword">return</span> <span class="name builtin pseudo">False</span>
        <span class="keyword">else</span><span class="punctuation">:</span> <span class="comment single"># 空树是BST</span>
            <span class="keyword">return</span> <span class="name builtin pseudo">True</span></code></pre>
</div>
<div class="section" id="arrayheight-balanced-bst">
<h2><a class="toc-backref" href="#id35"><span class="sectnum">4.12</span> 排好序的array转换到height-balanced BST</a></h2>
<pre class="code python literal-block"><code><span class="comment single"># 摘自108</span>

<span class="keyword">class</span> <span class="name class">Solution</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="name function">sortedArrayToBST</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="name">nums</span><span class="punctuation">:</span> <span class="name">List</span><span class="punctuation">[</span><span class="name builtin">int</span><span class="punctuation">])</span> <span class="operator">-&gt;</span> <span class="name">TreeNode</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="name builtin">len</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">)</span> <span class="operator">==</span> <span class="literal number integer">0</span><span class="punctuation">:</span> <span class="comment single"># 空树</span>
            <span class="keyword">return</span> <span class="name builtin pseudo">None</span>
        <span class="keyword">elif</span> <span class="name builtin">len</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">)</span> <span class="operator">==</span> <span class="literal number integer">1</span><span class="punctuation">:</span> <span class="comment single"># 数组只含一个元素</span>
            <span class="keyword">return</span> <span class="name">TreeNode</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">[</span><span class="literal number integer">0</span><span class="punctuation">])</span>
        <span class="keyword">else</span><span class="punctuation">:</span> <span class="comment single"># 数组含有2个及以上的元素，这时候可以继续拆</span>
            <span class="name">n</span> <span class="operator">=</span> <span class="name builtin">len</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">)</span>
            <span class="name">root</span> <span class="operator">=</span> <span class="name">TreeNode</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">[</span><span class="name">n</span> <span class="operator">//</span> <span class="literal number integer">2</span><span class="punctuation">])</span> <span class="comment single"># 取最中间一个元素作为根节点</span>
            <span class="name">root</span><span class="operator">.</span><span class="name">left</span> <span class="operator">=</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">sortedArrayToBST</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">[</span><span class="literal number integer">0</span><span class="punctuation">:</span> <span class="name">n</span> <span class="operator">//</span> <span class="literal number integer">2</span><span class="punctuation">])</span> <span class="comment single"># 构造左边子树</span>
            <span class="name">root</span><span class="operator">.</span><span class="name">right</span> <span class="operator">=</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">sortedArrayToBST</span><span class="punctuation">(</span><span class="name">nums</span><span class="punctuation">[</span><span class="name">n</span> <span class="operator">//</span> <span class="literal number integer">2</span> <span class="operator">+</span> <span class="literal number integer">1</span><span class="punctuation">:])</span> <span class="comment single"># 构造右边子树</span>
            <span class="keyword">return</span> <span class="name">root</span></code></pre>
<p>衍生</p>
<ul class="simple">
<li><p>1008 从二分搜索树的先根遍历路径重建出二分搜索树</p></li>
</ul>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id36"><span class="sectnum">4.13</span> 筛选出出现频次最高的元素</a></h2>
<p>提示一下，如果有多种元素出现的频次一样而且恰好最高，怎么写最好？</p>
<pre class="code python literal-block"><code><span class="comment single"># 摘自 https://leetcode.com/problems/most-frequent-subtree-sum/discuss/98675/Python-easy-understand-solution</span>

<span class="name">maximumFrequency</span> <span class="operator">=</span> <span class="name builtin">max</span><span class="punctuation">(</span><span class="name">counter</span><span class="operator">.</span><span class="name">values</span><span class="punctuation">())</span> <span class="comment single"># 首先得到最高频次</span>
<span class="keyword">return</span> <span class="punctuation">[</span><span class="name">i</span> <span class="keyword">for</span> <span class="name">i</span><span class="punctuation">,</span> <span class="name">v</span> <span class="operator word">in</span> <span class="name">counter</span><span class="operator">.</span><span class="name">items</span><span class="punctuation">()</span> <span class="keyword">if</span> <span class="name">v</span> <span class="operator">==</span> <span class="name">maximumFrequency</span><span class="punctuation">]</span> <span class="comment single"># 再筛选出频次和最高频次一样大的元素</span></code></pre>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id37"><span class="sectnum">4.14</span> 计算器</a></h2>
</div>
</div>
            </div>
</body>
</html>
        </div>
    </div>
</div>